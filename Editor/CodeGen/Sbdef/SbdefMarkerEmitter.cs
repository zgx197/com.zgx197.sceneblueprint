#nullable enable
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace SceneBlueprint.Editor.CodeGen.Sbdef
{
    /// <summary>
    /// v0.3 Emitter：从 SbdefFile 中的 MarkerDecl 生成 C# 代码。
    /// <list type="bullet">
    /// <item>UMarkerTypeIds.cs            — 类型 ID 字符串常量（Runtime）</item>
    /// <item>Markers/{Name}Marker.cs      — 每个 Marker 独立文件（Runtime MonoBehaviour）</item>
    /// <item>UMarkerDefs.cs              — IMarkerDefinitionProvider 实现（Editor-only）</item>
    /// </list>
    /// </summary>
    internal static class SbdefMarkerEmitter
    {
        /// <returns>
        /// 字典键以 "Editor/" 前缀开头的条目输出到 Generated/Editor/，
        /// 以 "Markers/" 前缀开头的条目输出到 Generated/Markers/（每个 Marker 独立文件）。
        /// </returns>
        public static Dictionary<string, string> Emit(SbdefFile ast, string sourceName)
        {
            var markers = ast.Statements.OfType<MarkerDecl>().ToList();
            if (markers.Count == 0)
                return new Dictionary<string, string>();

            var pascal = CapFirst(sourceName);
            var result = new Dictionary<string, string>
            {
                [$"UMarkerTypeIds.{pascal}.cs"]     = EmitTypeIds(markers, sourceName),
                [$"Editor/UMarkerDefs.{pascal}.cs"] = EmitMarkerDefs(markers, sourceName),
            };

            // 每个 Marker 生成独立 .cs 文件（文件名 = 类名，Unity MonoBehaviour 要求）
            foreach (var m in markers)
            {
                var className = m.Name + "Marker";
                result[$"Markers/{className}.cs"] = EmitSingleMarker(m, sourceName);
            }

            return result;
        }

        private static string CapFirst(string s)
            => string.IsNullOrEmpty(s) ? s : char.ToUpper(s[0]) + s.Substring(1);

        // ── UMarkerTypeIds 生成 ──────────────────────────────────

        private static string EmitTypeIds(List<MarkerDecl> markers, string sourceName)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine($"// 由 SbdefCodegen 从 {sourceName}.sbdef 生成，请勿手动修改。");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("namespace SceneBlueprintUser.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    public static partial class UMarkerTypeIds");
            sb.AppendLine("    {");

            foreach (var m in markers)
            {
                var label = m.Label ?? m.Name;
                sb.AppendLine($"        /// <summary>{label}</summary>");
                sb.AppendLine($"        public const string {m.Name} = \"{m.Name}\";");
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        // ── 单个 Marker 独立文件生成 ─────────────────────────────

        private static string EmitSingleMarker(MarkerDecl m, string sourceName)
        {
            var className = m.Name + "Marker";
            var baseClass = m.BaseType != null ? $"{m.BaseType}Marker" : "SceneMarker";
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated>");
            sb.AppendLine($"// 由 SbdefCodegen 从 {sourceName}.sbdef 生成，请勿手动修改。");
            sb.AppendLine("// 手写业务字段请在对应的 partial 文件中扩展，勿修改此文件。");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using UnityEngine;");
            sb.AppendLine("using SceneBlueprint.Runtime.Markers;");
            sb.AppendLine();
            sb.AppendLine("namespace SceneBlueprintUser.Generated");
            sb.AppendLine("{");
            sb.AppendLine($"    public class {className} : {baseClass}");
            sb.AppendLine("    {");
            sb.AppendLine($"        public override string MarkerTypeId => UMarkerTypeIds.{m.Name};");

            if (!string.IsNullOrEmpty(m.GizmoShape))
            {
                var param = m.GizmoParam != null ? $"({m.GizmoParam})" : "";
                sb.AppendLine($"        // gizmo: {m.GizmoShape}{param}  — 在对应的 Editor Gizmo Drawer 中实现");
            }

            // 阶段4：声明式关联 use_annotations
            if (m.UsedAnnotations != null && m.UsedAnnotations.Count > 0)
            {
                sb.AppendLine();
                sb.AppendLine("#if UNITY_EDITOR");
                sb.AppendLine("        protected override void Reset()");
                sb.AppendLine("        {");
                sb.AppendLine("            base.Reset();");
                foreach (var annotationName in m.UsedAnnotations)
                {
                    var annotationClass = $"SceneBlueprintUser.Annotations.{annotationName}Annotation";
                    sb.AppendLine($"            // 自动添加 {annotationName}");
                    sb.AppendLine($"            if (GetComponent<{annotationClass}>() == null)");
                    sb.AppendLine($"                gameObject.AddComponent<{annotationClass}>();");
                }
                sb.AppendLine("        }");
                sb.AppendLine("#endif");
            }
            // 阶段3：嵌套式 Annotation（兼容旧代码）
            else if (m.Annotations != null && m.Annotations.Count > 0)
            {
                sb.AppendLine();
                sb.AppendLine("#if UNITY_EDITOR");
                sb.AppendLine("        protected override void Reset()");
                sb.AppendLine("        {");
                sb.AppendLine("            base.Reset();");
                foreach (var annotation in m.Annotations)
                {
                    var annotationClass = $"SceneBlueprintUser.Annotations.{annotation.Name}Annotation";
                    sb.AppendLine($"            // 自动添加 {annotation.DisplayName ?? annotation.Name}");
                    sb.AppendLine($"            if (GetComponent<{annotationClass}>() == null)");
                    sb.AppendLine($"                gameObject.AddComponent<{annotationClass}>();");
                }
                sb.AppendLine("        }");
                sb.AppendLine("#endif");
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        // ── UMarkerDefs（IMarkerDefinitionProvider）生成 ────────

        private static string EmitMarkerDefs(List<MarkerDecl> markers, string sourceName)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine($"// 由 SbdefCodegen 从 {sourceName}.sbdef 生成，请勿手动修改。");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using SceneBlueprint.Editor.Markers.Definitions;");
            sb.AppendLine("using SceneBlueprint.Runtime.Markers;");
            sb.AppendLine("using SceneBlueprintUser.Generated;");
            sb.AppendLine();
            sb.AppendLine("namespace SceneBlueprintUser.Generated.Editor");
            sb.AppendLine("{");

            foreach (var m in markers)
            {
                var className   = m.Name + "Marker";
                var defClass    = m.Name + "MarkerDef";
                var displayName = m.Label ?? m.Name;

                sb.AppendLine($"    [MarkerDef(UMarkerTypeIds.{m.Name})]");
                sb.AppendLine($"    public class {defClass} : IMarkerDefinitionProvider");
                sb.AppendLine("    {");
                sb.AppendLine("        public MarkerDefinition Define() => new MarkerDefinition");
                sb.AppendLine("        {");
                sb.AppendLine($"            TypeId        = UMarkerTypeIds.{m.Name},");
                sb.AppendLine($"            DisplayName   = \"{EscapeString(displayName)}\",");
                sb.AppendLine($"            ComponentType = typeof({className}),");
                sb.AppendLine("            DefaultSpacing = 2f,");
                if (!string.IsNullOrEmpty(m.Group))
                    sb.AppendLine($"            Group         = \"{EscapeString(m.Group)}\",");
                sb.AppendLine("        };");
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            sb.AppendLine("}");
            return sb.ToString();
        }

        private static string EscapeString(string s)
            => s.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }
}
