#nullable enable
using System.Collections.Generic;
using System.Text;

namespace SceneBlueprint.Editor.CodeGen.Sbdef
{
    /// <summary>
    /// .sbdef EditorTool ä»£ç ç”Ÿæˆå™¨ â€” ä» editor_tool å—ç”Ÿæˆ IMarkerEditorExtension å®ç°ç±»ã€‚
    /// <para>
    /// ç”Ÿæˆäº§ç‰©ï¼š
    /// - Editor/EditorTools/{ToolName}.cs â€” Editor Tool ç±»ï¼ˆpartialï¼ŒUI ä»£ç ç”±å¼€å‘è€…è¡¥å……ï¼‰
    /// </para>
    /// </summary>
    internal static class SbdefEditorToolEmitter
    {
        public static Dictionary<string, string> Emit(SbdefFile ast, string sourceName)
        {
            var output = new Dictionary<string, string>();

            foreach (var stmt in ast.Statements)
            {
                if (stmt is MarkerDecl marker && marker.EditorTools != null)
                {
                    foreach (var tool in marker.EditorTools)
                    {
                        var toolCode = GenerateEditorToolClass(tool, marker.Name);
                        output[$"Editor/EditorTools/{tool.Name}.cs"] = toolCode;
                    }
                }
            }

            return output;
        }

        private static string GenerateEditorToolClass(EditorToolDecl tool, string markerName)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine($"// ç”± SbdefCodegen ç”Ÿæˆï¼ŒUI ä»£ç è¯·åœ¨ partial ç±»ä¸­è¡¥å……ã€‚");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using UnityEngine;");
            sb.AppendLine("using UnityEditor;");
            sb.AppendLine("using SceneBlueprint.Runtime.Markers;");
            sb.AppendLine("using SceneBlueprint.Editor.Markers.Extensions;");
            sb.AppendLine();
            sb.AppendLine("namespace SceneBlueprintUser.Editor.EditorTools");
            sb.AppendLine("{");
            
            var displayName = tool.DisplayName ?? tool.Name;
            sb.AppendLine($"    [MarkerEditorExtension(\"{markerName}\")]");
            sb.AppendLine($"    public partial class {tool.Name}");
            sb.AppendLine("        : IMarkerEditorExtension");
            sb.AppendLine("    {");
            sb.AppendLine($"        public string TargetMarkerTypeId => \"{markerName}\";");
            sb.AppendLine($"        public string DisplayName => \"{displayName}\";");
            sb.AppendLine();
            
            // ç”Ÿæˆç§æœ‰å­—æ®µ
            sb.AppendLine("        // å·¥å…·çŠ¶æ€å­—æ®µ");
            sb.AppendLine("        private bool _foldout;");
            
            foreach (var param in tool.Parameters)
            {
                GenerateToolParameter(sb, param);
            }
            
            // ç”Ÿæˆ enum å®šä¹‰
            foreach (var param in tool.Parameters)
            {
                if (param.TypeName == "enum" && param.EnumValues != null)
                {
                    sb.AppendLine();
                    GenerateEnumDefinition(sb, param);
                }
            }

            sb.AppendLine();
            sb.AppendLine("        // UI ç»˜åˆ¶æ–¹æ³•ï¼ˆç”±å¼€å‘è€…åœ¨ partial ç±»ä¸­å®ç°ï¼‰");
            sb.AppendLine("        partial void DrawToolUI(SceneMarker marker);");
            sb.AppendLine();
            sb.AppendLine("        public void DrawInspectorGUI(SceneMarker marker)");
            sb.AppendLine("        {");
            sb.AppendLine("            _foldout = EditorGUILayout.BeginFoldoutHeaderGroup(_foldout, \"ğŸ”§ \" + DisplayName);");
            sb.AppendLine("            if (_foldout)");
            sb.AppendLine("            {");
            sb.AppendLine("                EditorGUI.indentLevel++;");
            sb.AppendLine("                DrawToolUI(marker);");
            sb.AppendLine("                EditorGUI.indentLevel--;");
            sb.AppendLine("            }");
            sb.AppendLine("            EditorGUILayout.EndFoldoutHeaderGroup();");
            sb.AppendLine("        }");
            
            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        private static void GenerateToolParameter(StringBuilder sb, ToolParameterDecl param)
        {
            var csType = MapParameterType(param);
            var defaultValue = GetParameterDefaultValue(param);
            var fieldName = "_" + ToCamel(param.Name);
            
            sb.AppendLine($"        private {csType} {fieldName} = {defaultValue};");
        }

        private static void GenerateEnumDefinition(StringBuilder sb, ToolParameterDecl param)
        {
            if (param.EnumValues == null || param.EnumValues.Count == 0) return;
            
            var enumName = ToPascal(param.Name);
            sb.AppendLine($"        public enum {enumName}");
            sb.AppendLine("        {");
            for (int i = 0; i < param.EnumValues.Count; i++)
            {
                var comma = i < param.EnumValues.Count - 1 ? "," : "";
                sb.AppendLine($"            {param.EnumValues[i]}{comma}");
            }
            sb.AppendLine("        }");
        }

        private static string MapParameterType(ToolParameterDecl param)
        {
            if (param.TypeName == "enum")
            {
                return ToPascal(param.Name);
            }
            
            return param.TypeName switch
            {
                "int" => "int",
                "float" => "float",
                "bool" => "bool",
                "string" => "string",
                _ => "object"
            };
        }

        private static string GetParameterDefaultValue(ToolParameterDecl param)
        {
            if (!string.IsNullOrEmpty(param.DefaultValue))
            {
                if (param.TypeName == "string")
                    return $"\"{param.DefaultValue}\"";
                if (param.TypeName == "float" && !param.DefaultValue.EndsWith("f"))
                    return param.DefaultValue + "f";
                if (param.TypeName == "enum" && param.EnumValues != null && param.EnumValues.Count > 0)
                    return $"{ToPascal(param.Name)}.{param.EnumValues[0]}";
                return param.DefaultValue;
            }

            return param.TypeName switch
            {
                "int" => "0",
                "float" => "0f",
                "bool" => "false",
                "string" => "\"\"",
                "enum" => param.EnumValues != null && param.EnumValues.Count > 0 
                    ? $"{ToPascal(param.Name)}.{param.EnumValues[0]}" 
                    : "0",
                _ => "default!"
            };
        }

        private static string ToPascal(string s)
        {
            if (string.IsNullOrEmpty(s)) return s;
            return char.ToUpper(s[0]) + s.Substring(1);
        }

        private static string ToCamel(string s)
        {
            if (string.IsNullOrEmpty(s)) return s;
            return char.ToLower(s[0]) + s.Substring(1);
        }
    }
}
