#nullable enable
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;

namespace SceneBlueprint.Editor.CodeGen.Sbdef
{
    /// <summary>
    /// v0.2 Emitter：从 SbdefFile 生成两份 C# 代码。
    /// <list type="bullet">
    /// <item>UActionPortIds.{Segment}.cs — PropertyKey&lt;T&gt; 类型化端口键</item>
    /// <item>ActionDefs.{Segment}.cs     — IActionDefinitionProvider 完整实现</item>
    /// </list>
    /// </summary>
    internal static class SbdefDefEmitter
    {
        public static Dictionary<string, string> Emit(SbdefFile ast, string sourceName)
        {
            var actions = ast.Statements.OfType<ActionDecl>().ToList();
            if (actions.Count == 0)
                return new Dictionary<string, string>();

            var groups = actions
                .GroupBy(a => FirstSegment(a.TypeId))
                .ToList();

            var result = new Dictionary<string, string>();
            foreach (var grp in groups)
            {
                var ns     = grp.Key;
                var pascal = SbdefActionEmitter.ToPascalSegment(ns);
                var list   = grp.ToList();

                result[$"UActionPortIds.{pascal}.cs"] = EmitPortIds(list, pascal, sourceName);
                result[$"ActionDefs.{pascal}.cs"]     = EmitActionDefs(list, pascal, sourceName);
            }
            return result;
        }

        // ── UActionPortIds 生成 ──────────────────────────────────

        private static string EmitPortIds(
            List<ActionDecl> actions, string segmentPascal, string sourceName)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine($"// 由 SbdefCodegen 从 {sourceName}.sbdef 生成，请勿手动修改。");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using SceneBlueprint.Core;");
            sb.AppendLine();
            sb.AppendLine("namespace SceneBlueprintUser.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    public static partial class UActionPortIds");
            sb.AppendLine("    {");

            foreach (var action in actions)
            {
                var className = TypeIdToClassName(action.TypeId); // e.g. VFXCameraShake
                sb.AppendLine($"        public static class {className}");
                sb.AppendLine("        {");
                sb.AppendLine("            public const string In  = \"in\";");
                sb.AppendLine("            public const string Out = \"out\";");

                foreach (var port in action.Ports)
                {
                    var fieldName  = port.PortName;                           // PascalCase
                    var keyString  = ToCamelCase(port.PortName);             // camelCase
                    var csharpType = PortTypeToCSharp(port.TypeName);        // "float"
                    sb.AppendLine($"            public static readonly PropertyKey<{csharpType}> {fieldName} = new(\"{keyString}\");");
                }

                // 数据端口的 PortId 常量（outport / inport → const string）
                foreach (var port in action.Ports)
                {
                    if (port.DataDirection == null) continue;
                    // 在上面的循环里已经生成了 PropertyKey，这里额外生成 PortId 常量
                    // 实际上 PropertyKey 本身可以隐式转 string，无需重复生成
                    // 留空：PropertyKey<T> 已经足够
                }

                foreach (var fp in action.FlowPorts)
                {
                    var keyString = ToCamelCase(fp.PortName);
                    sb.AppendLine($"            public const string {fp.PortName} = \"{keyString}\";");
                }

                sb.AppendLine("        }");
                sb.AppendLine();
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        // ── ActionDefs 生成 ──────────────────────────────────────

        private static string EmitActionDefs(
            List<ActionDecl> actions, string segmentPascal, string sourceName)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine($"// 由 SbdefCodegen 从 {sourceName}.sbdef 生成，请勿手动修改。");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using NodeGraph.Math;");
            sb.AppendLine("using SceneBlueprint.Contract;");
            sb.AppendLine("using SceneBlueprint.Core;");
            sb.AppendLine();
            sb.AppendLine("namespace SceneBlueprintUser.Generated");
            sb.AppendLine("{");

            foreach (var action in actions)
            {
                var className  = TypeIdToClassName(action.TypeId); // VFXCameraShake
                var defClass   = className + "Def";                 // VFXCameraShakeDef
                var uatRef     = TypeIdToUatRef(action.TypeId);    // UAT.Vfx.CameraShake
                var meta       = action.Meta;

                sb.AppendLine($"    [ActionType({uatRef})]");
                sb.AppendLine($"    public class {defClass} : IActionDefinitionProvider");
                sb.AppendLine("    {");
                sb.AppendLine("        public ActionDefinition Define() => new ActionDefinition");
                sb.AppendLine("        {");
                sb.AppendLine($"            TypeId      = {uatRef},");

                // DisplayName：有则用，无则用 TypeId 末段
                var displayName = meta.DisplayName ?? LastSegment(action.TypeId);
                sb.AppendLine($"            DisplayName = \"{EscapeString(displayName)}\",");

                if (!string.IsNullOrEmpty(meta.Category))
                    sb.AppendLine($"            Category    = \"{EscapeString(meta.Category!)}\",");

                if (!string.IsNullOrEmpty(meta.Description))
                    sb.AppendLine($"            Description = \"{EscapeString(meta.Description!)}\",");

                if (!string.IsNullOrEmpty(meta.ThemeColor))
                {
                    var color = ParseThemeColor(meta.ThemeColor!);
                    if (color != null)
                        sb.AppendLine($"            ThemeColor  = new Color4({color}),");
                }

                var duration = ParseDuration(meta.Duration);
                sb.AppendLine($"            Duration    = {duration},");

                // Ports
                sb.AppendLine("            Ports = new[]");
                sb.AppendLine("            {");
                sb.AppendLine($"                Port.In(UActionPortIds.{className}.In,  \"输入\"),");
                sb.AppendLine($"                Port.Out(UActionPortIds.{className}.Out, \"输出\"),");
                foreach (var fp in action.FlowPorts)
                {
                    var portLabel = fp.Label ?? fp.PortName;
                    sb.AppendLine($"                Port.Out(UActionPortIds.{className}.{fp.PortName}, \"{EscapeString(portLabel)}\"),");
                }
                // 数据端口（outport / inport）
                foreach (var port in action.Ports)
                {
                    if (port.DataDirection == null) continue;
                    var pLabel   = port.Label ?? port.PortName;
                    var pKeyRef  = $"UActionPortIds.{className}.{port.PortName}";
                    var pDataType = port.TypeName; // "int", "float", "string", "bool"
                    if (port.DataDirection == "out")
                        sb.AppendLine($"                Port.DataOut({pKeyRef}, \"{EscapeString(pLabel)}\", \"{pDataType}\"),");
                    else
                        sb.AppendLine($"                Port.DataIn({pKeyRef}, \"{EscapeString(pLabel)}\", \"{pDataType}\"),");
                }
                sb.AppendLine("            },");

                // Properties（跳过数据端口 outport/inport）
                var propPorts = action.Ports.Where(p => p.DataDirection == null).ToList();
                if (propPorts.Count > 0)
                {
                    sb.AppendLine("            Properties = new[]");
                    sb.AppendLine("            {");
                    int order = 0;
                    foreach (var port in propPorts)
                    {
                        var propLine = BuildPropLine(className, port, order++);
                        sb.AppendLine($"                {propLine}");
                    }
                    sb.AppendLine("            },");
                }
                else
                {
                    sb.AppendLine("            Properties = System.Array.Empty<PropertyDefinition>(),");
                }

                // SceneRequirements
                if (action.Requirements != null && action.Requirements.Count > 0)
                {
                    sb.AppendLine("            SceneRequirements = new MarkerRequirement[]");
                    sb.AppendLine("            {");
                    foreach (var req in action.Requirements)
                    {
                        var bindingKey = ToCamelCase(req.PortName);
                        var reqLabel   = req.Label ?? req.PortName;
                        var reqVal     = req.IsRequired ? "true" : "false";
                        sb.AppendLine($"                new MarkerRequirement(\"{bindingKey}\", \"{req.MarkerType}\", required: {reqVal}, displayName: \"{EscapeString(reqLabel)}\"),");
                    }
                    sb.AppendLine("            }");
                }
                else
                {
                    sb.AppendLine("            SceneRequirements = System.Array.Empty<MarkerRequirement>()");
                }
                sb.AppendLine("        };");
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            sb.AppendLine("}");
            return sb.ToString();
        }

        // ── 辅助：生成单条 Prop.* 调用 ──────────────────────────

        private static string BuildPropLine(string className, PortDecl port, int order)
        {
            var keyRef   = $"UActionPortIds.{className}.{port.PortName}";
            var label    = port.Label ?? port.PortName;
            var labelLit = $"\"{EscapeString(label)}\"";
            var typeName = port.TypeName.ToLower();

            // sceneref(Area/Point) → Prop.SceneBinding
            if (typeName == "sceneref")
            {
                var bindingType = port.SceneRefType ?? "Transform";
                return $"Prop.SceneBinding({keyRef}, {labelLit}, BindingType.{bindingType}, order: {order}),";
            }

            // list → Prop.StructList
            if (typeName == "list")
            {
                var summary = port.Summary != null ? $"\"{EscapeString(port.Summary)}\"" : "null";
                if (port.NestedPortFields != null && port.NestedPortFields.Count > 0)
                {
                    var fieldLines = new System.Text.StringBuilder();
                    foreach (var f in port.NestedPortFields)
                    {
                        var fLabel = f.Label ?? f.Name;
                        var fKey   = ToCamelCase(f.Name);
                        fieldLines.Append(BuildNestedFieldProp(fKey, fLabel, f.TypeName, f.EnumValues));
                        fieldLines.Append(", ");
                    }
                    return $"Prop.StructList({keyRef}, {labelLit}, new PropertyDefinition[] {{ {fieldLines}}}, summaryFormat: {summary}, order: {order}),";
                }
                return $"Prop.StructList({keyRef}, {labelLit}, System.Array.Empty<PropertyDefinition>(), summaryFormat: {summary}, order: {order}),";
            }

            var defaultVal = port.DefaultValue;
            var min        = port.Min;
            var max        = port.Max;

            switch (typeName)
            {
                case "float":
                {
                    var def  = FormatFloat(defaultVal ?? "0");
                    var args = $"{keyRef}, {labelLit}, defaultValue: {def}";
                    if (min != null) args += $", min: {FormatFloat(min)}";
                    if (max != null) args += $", max: {FormatFloat(max)}";
                    args += $", order: {order}";
                    return $"Prop.Float({args}),";
                }
                case "int":
                {
                    var def  = FormatInt(defaultVal ?? "0");
                    var args = $"{keyRef}, {labelLit}, defaultValue: {def}";
                    if (min != null) args += $", min: {FormatInt(min)}";
                    if (max != null) args += $", max: {FormatInt(max)}";
                    args += $", order: {order}";
                    return $"Prop.Int({args}),";
                }
                case "bool":
                {
                    var def = (defaultVal ?? "false").ToLower();
                    return $"Prop.Bool({keyRef}, {labelLit}, defaultValue: {def}, order: {order}),";
                }
                default: // string 或其他类型
                {
                    var def = defaultVal != null ? $"\"{EscapeString(defaultVal)}\"" : "\"\"";
                    return $"Prop.String({keyRef}, {labelLit}, defaultValue: {def}, order: {order}),";
                }
            }
        }

        /// <summary>为 StructList 嵌套字段生成 Prop.* 调用片段（不含尾部逗号）</summary>
        private static string BuildNestedFieldProp(string camelKey, string label, string typeName,
            System.Collections.Generic.List<string>? enumValues = null)
        {
            var labelLit = $"\"{EscapeString(label)}\"";
            if (typeName.ToLower() == "enum" && enumValues != null && enumValues.Count > 0)
            {
                var opts = string.Join(", ", enumValues.Select(v => $"\"{v}\""));
                return $"Prop.Enum(\"{camelKey}\", {labelLit}, new[] {{ {opts} }})";
            }
            return typeName.ToLower() switch
            {
                "float"  => $"Prop.Float(\"{camelKey}\", {labelLit})",
                "int"    => $"Prop.Int(\"{camelKey}\", {labelLit})",
                "bool"   => $"Prop.Bool(\"{camelKey}\", {labelLit})",
                _        => $"Prop.String(\"{camelKey}\", {labelLit})",
            };
        }

        // ── 名称转换工具 ─────────────────────────────────────────

        /// <summary>"VFX.CameraShake" → "VFXCameraShake"（去除 . 连接）</summary>
        private static string TypeIdToClassName(string typeId)
            => typeId.Replace(".", "");

        /// <summary>"VFX.CameraShake" → "UAT.Vfx.CameraShake"</summary>
        private static string TypeIdToUatRef(string typeId)
        {
            var segments = typeId.Split('.');
            if (segments.Length < 2) return $"UAT.{typeId}";
            var ns   = SbdefActionEmitter.ToPascalSegment(segments[0]);
            var name = segments[segments.Length - 1];
            return $"UAT.{ns}.{name}";
        }

        /// <summary>"VFX.CameraShake" → "VFX"</summary>
        private static string FirstSegment(string typeId)
        {
            var dot = typeId.IndexOf('.');
            return dot < 0 ? typeId : typeId.Substring(0, dot);
        }

        /// <summary>"VFX.CameraShake" → "CameraShake"</summary>
        private static string LastSegment(string typeId)
        {
            var dot = typeId.LastIndexOf('.');
            return dot < 0 ? typeId : typeId.Substring(dot + 1);
        }

        /// <summary>"Duration" → "duration"（首字母小写，即 camelCase）</summary>
        private static string ToCamelCase(string s)
        {
            if (string.IsNullOrEmpty(s)) return s;
            return char.ToLower(s[0]) + s.Substring(1);
        }

        // ── 类型映射 ─────────────────────────────────────────────

        private static string PortTypeToCSharp(string dslType)
        {
            return dslType.ToLower() switch
            {
                "float"    => "float",
                "int"      => "int",
                "bool"     => "bool",
                "string"   => "string",
                "sceneref" => "string", // 场景绑定存储为 marker ID 字符串
                "list"     => "string", // StructList 存储为 JSON 字符串
                _          => "string",
            };
        }

        // ── 值格式化 ─────────────────────────────────────────────

        private static string FormatFloat(string s)
        {
            if (float.TryParse(s, NumberStyles.Float, CultureInfo.InvariantCulture, out var v))
                return v.ToString("G", CultureInfo.InvariantCulture) + "f";
            return "0f";
        }

        private static string FormatInt(string s)
        {
            if (int.TryParse(s, out var v)) return v.ToString();
            return "0";
        }

        private static string EscapeString(string s)
            => s.Replace("\\", "\\\\").Replace("\"", "\\\"");

        // ── 元数据解析 ───────────────────────────────────────────

        /// <summary>"0.2 0.6 1.0" → "0.2f, 0.6f, 1.0f"</summary>
        private static string? ParseThemeColor(string raw)
        {
            var parts = raw.Split(' ');
            if (parts.Length < 3) return null;
            return $"{FormatFloat(parts[0])}, {FormatFloat(parts[1])}, {FormatFloat(parts[2])}";
        }

        /// <summary>"instant" → "ActionDuration.Instant"</summary>
        private static string ParseDuration(string? raw)
        {
            return (raw?.ToLower()) switch
            {
                "duration" => "ActionDuration.Duration",
                "passive"  => "ActionDuration.Passive",
                _          => "ActionDuration.Instant",
            };
        }
    }
}
