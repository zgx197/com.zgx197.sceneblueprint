# 数据端口系统设计文档

> 版本：1.0 · 日期：2026-02-20  
> 目标：为蓝图系统引入数据端口（Data Port）和数据边（Data Edge），
> 解决多个同类节点（如多个 `Spawn.Wave`）产出变量身份不明的问题，
> 并向 UE Blueprint 的"控制流 + 数据流混合图"模型演进。

---

## 1. 现有基础（无需新建）

阅读代码发现以下基础设施已就绪，**不需要改动**：

| 文件 | 已有内容 |
|------|---------|
| `PortDefinition.cs` | `PortKind.Control/Event/Data`，`DataType`，`Required`；`Port.DataIn()` / `Port.DataOut()` 工厂方法 |
| `EdgeData.cs` | `Kind`（PortKind）和 `DataType` 字段，数据边已可表示 |
| `SpawnWaveSystem.cs` | 已用 `{actionId}.waveIndex` 写入 Blackboard（scoped key）|

这意味着**端口声明模型、连线元数据模型已完整**，缺的是：
1. 导出格式中的 DataConnections 表
2. 运行时帧中的数据端口值存储
3. 各 System 的读写接入
4. 编辑器数据边的渲染样式

---

## 2. 核心概念

### 2.1 两类边的语义对比

```
Flow Edge（控制流边）:  A.outPort ──────►  B.inPort     触发执行
Data Edge（数据边）:   A.dataOut  ·····►  B.dataIn     传递值（不触发）
```

- 控制流边触发节点进入 `Running` 状态
- 数据边只携带值，不触发执行；节点执行时**主动读取**已连接的数据端口值

### 2.2 数据端口值的生命周期

```
SpawnWaveSystem.Update()
  → 每波开始时写入 DataPortValues[actionIndex]["waveIndex"] = currentWave
  → 同时触发 onWaveStart Flow 事件

FlowFilterSystem.Update()（被 onWaveStart 触发后执行）
  → 检查 compareValue 端口是否有 DataConnection
  → 有 → 读 DataPortValues[fromActionIndex][fromPortId]
  → 无 → fallback: 读 Blackboard（原有逻辑，已删除）
```

### 2.3 数据端口值类型

所有数据端口值在运行时**统一以 `string` 存储**（与属性系统保持一致），
在各 System 内按需解析为 int/float/bool。

---

## 3. 变更范围

### 3.1 `SceneBlueprintData.cs` ── 新增 DataConnections

```csharp
// 新增字段
public DataConnectionEntry[] DataConnections = Array.Empty<DataConnectionEntry>();

// 新增类
[Serializable]
public class DataConnectionEntry
{
    public string FromActionId = "";
    public string FromPortId   = "";
    public string ToActionId   = "";
    public string ToPortId     = "";
}
```

控制流边继续存在 `Transitions[]`，数据边存放在 `DataConnections[]`，两者完全分离。

---

### 3.2 `BlueprintFrame.cs` ── 新增 DataPortValues 和辅助索引

**静态数据**（由 BlueprintLoader 初始化）：

```csharp
// DataConnectionEntry 原始数组
public DataConnectionEntry[] DataConnections { get; internal set; }

// 快速查找：(toActionIndex, toPortId) → (fromActionIndex, fromPortId)
// 运行时 DataIn 端口读值时使用
public Dictionary<(int, string), (int, string)> DataInConnections { get; internal set; }
```

**动态数据**（由各 System 读写）：

```csharp
// 数据端口运行时值：actionIndex → (portId → stringValue)
// SpawnWaveSystem 写，FlowFilterSystem 读
public Dictionary<int, Dictionary<string, string>> DataPortValues { get; } = new();
```

**新增辅助方法**：

```csharp
// 写数据端口（供生产者 System 调用）
public void SetDataPortValue(int actionIndex, string portId, string value)

// 读数据端口（供消费者 System 调用）
// 返回 null 表示该 DataIn 端口无连接（应 fallback 或报警）
public string? GetDataPortValue(int actionIndex, string toPortId)
```

---

### 3.3 `SpawnWaveDef.cs` ── 新增 DataOut 端口

```csharp
Ports = new[] {
    Port.In("in", "输入"),
    Port.Out("out", "全部完成"),
    Port.Out("onWaveStart", "每波开始"),
    Port.DataOut("waveIndex",  "当前波次", DataTypes.Int),   // 新增
    Port.DataOut("totalWaves", "总波次数", DataTypes.Int),   // 新增
},
```

`DataTypes.Int` 等类型字符串常量在 `Core/DataTypes.cs` 中统一定义（见 3.7）。

---

### 3.4 `FlowFilterDef.cs` ── 新增 DataIn 端口，移除 Blackboard 属性

```csharp
Ports = new[] {
    Port.In("in", "输入"),
    Port.DataIn("compareValue", "比较值", DataTypes.Any),   // 新增
    Port.Out("pass",   "满足"),
    Port.Out("reject", "不满足"),
},
Properties = new[] {
    // 移除 variableIndex 和 value（由 DataIn 端口替代）
    Prop.Enum("op", "操作符",
        new[] { "==", "!=", ">", "<", ">=", "<=" },
        defaultValue: "==", order: 0),
    Prop.String("constValue", "常量（无连线时）",
        defaultValue: "0", order: 1),
},
```

`DataTypes.Any` 表示接受任意类型，运行时按字符串比较（与现有 EvaluateCondition 逻辑一致）。

---

### 3.5 `SpawnWaveSystem.cs` ── 写 DataPortValues

在每波开始时，**写数据端口值**：

```csharp
// 原有（保留用于调试，可选删除）
frame.Blackboard.SetInternal($"{actionId}.waveIndex", currentWave);

// 新增：写数据端口值
frame.SetDataPortValue(actionIndex, "waveIndex",  currentWave.ToString());
frame.SetDataPortValue(actionIndex, "totalWaves", waveEntries.Length.ToString());
```

---

### 3.6 `FlowFilterSystem.cs` ── 读 DataPortValues

替换原有 Blackboard + variableIndex 逻辑：

```csharp
private static void ProcessFilter(BlueprintFrame frame, int actionIndex, ref ActionRuntimeState state)
{
    var op         = frame.GetProperty(actionIndex, "op");
    var constValue = frame.GetProperty(actionIndex, "constValue");

    // 优先读 DataIn 端口（有连线时）
    string? compareValue = frame.GetDataPortValue(actionIndex, "compareValue");

    if (compareValue == null)
    {
        // DataIn 无连线：走常量比较（constValue == constValue 永远成立，通常视为"跳过过滤"）
        // 或者直接 pass/reject 由策划配置决定
        Debug.LogWarning($"[FlowFilterSystem] compareValue 端口无连接，走 pass（无条件通过）");
        EmitPortEvents(frame, actionIndex, "pass");
        state.Phase = ActionPhase.Listening;
        state.TransitionPropagated = true;
        return;
    }

    bool conditionMet = EvaluateCondition(compareValue, op, constValue);
    // ... 其余逻辑不变
}
```

---

### 3.7 `DataTypes.cs` ── 新增类型常量（已有文件，补充常量）

```csharp
public static class DataTypes
{
    public const string Int    = "Int";
    public const string Float  = "Float";
    public const string Bool   = "Bool";
    public const string String = "String";
    public const string Any    = "";   // 空串 = 接受任意类型
}
```

---

### 3.8 `BlueprintExporter.cs` ── 导出 DataConnections

在 `Export()` 的 Step 5 中：

```csharp
var dataConnections = ExportDataConnections(graph);
var data = new SceneBlueprintData {
    ...
    DataConnections = dataConnections,
};
```

```csharp
private static DataConnectionEntry[] ExportDataConnections(Graph graph)
{
    var result = new List<DataConnectionEntry>();
    foreach (var edge in graph.Edges)
    {
        if (edge.UserData is not EdgeData ed || ed.Kind != PortKind.Data) continue;
        result.Add(new DataConnectionEntry {
            FromActionId = edge.FromNodeId,
            FromPortId   = edge.FromPortId,
            ToActionId   = edge.ToNodeId,
            ToPortId     = edge.ToPortId,
        });
    }
    return result.ToArray();
}
```

---

### 3.9 `BlueprintLoader.cs` ── 加载 DataConnections 并构建索引

```csharp
// 构建 DataInConnections 反向索引
var dataInIndex = new Dictionary<(int, string), (int, string)>();
foreach (var dc in data.DataConnections)
{
    int fromIdx = frame.GetActionIndex(dc.FromActionId);
    int toIdx   = frame.GetActionIndex(dc.ToActionId);
    if (fromIdx >= 0 && toIdx >= 0)
        dataInIndex[(toIdx, dc.ToPortId)] = (fromIdx, dc.FromPortId);
}
frame.DataInConnections = dataInIndex;
```

---

### 3.10 编辑器渲染 ── 数据边样式

在 `SceneBlueprintRenderer`（或等效渲染类）中，区分边类型：

```
Control/Event 边：白色或灰白，线宽 2px（现有样式）
Data 边：       彩色细线，线宽 1.5px，颜色按数据类型区分
               Int → 绿色 #66BB6A
               Float → 黄色 #FFA726  
               Any → 浅蓝 #64B5F6
```

数据端口渲染：
- 小圆点（而非三角形）
- 颜色与对应数据类型一致

---

## 4. 不需要改动的内容

| 内容 | 原因 |
|------|------|
| `PortDefinition.cs` | 已完整支持 Data 端口 |
| `EdgeData.cs` | 已有 Kind 字段 |
| `ConnectionValidator.cs` | 需确认是否已允许 Data→Data，若未处理则补充 |
| `Blackboard.cs` | 保留，Global 变量仍使用 |
| `VariableDeclaration` + 变量面板 | 保留，全局 Blackboard 变量继续工作 |
| `BlackboardSetSystem` / `BlackboardGetSystem` | 保留，与数据端口并行存在 |

---

## 5. 实现顺序

```
Step 1  SceneBlueprintData 新增 DataConnectionEntry + DataConnections 字段
Step 2  BlueprintFrame 新增 DataPortValues + DataInConnections + 辅助方法
Step 3  SpawnWaveDef 新增 DataOut 端口
Step 4  FlowFilterDef 重写（DataIn 替换 variableIndex+value）
Step 5  SpawnWaveSystem 追加 SetDataPortValue 调用
Step 6  FlowFilterSystem 重写 ProcessFilter（读 DataPortValue）
Step 7  BlueprintExporter 导出 DataConnections
Step 8  BlueprintLoader 加载 DataConnections 并建索引
Step 9  编辑器渲染区分数据边样式
```

---

## 6. 最终效果

策划在编辑器中：
1. 从 `Spawn.Wave.当前波次`（绿色圆点，DataOut）拖线到 `Flow.Filter.比较值`（绿色圆点，DataIn）
2. `Flow.Filter` Inspector 只剩 `操作符` 和 `常量（无连线时）` 两个属性
3. 两个不同的 `Spawn.Wave` 节点各自连到自己的 `Flow.Filter`，互不干扰

运行时：
- `SpawnWaveSystem` 每波写 `DataPortValues[idx]["waveIndex"] = "3"`
- `FlowFilterSystem` 读 `DataPortValues[sourceIdx]["waveIndex"]` → 与常量比较 → emit pass/reject
