# 场景蓝图系统总体设计（SceneBlueprint）

> 版本：v1.6  
> 日期：2026-02-17  
> 状态：Phase 4B-2 已完成（SceneMarker 体系 + Gizmo 管线 + 绑定系统 + 日志系统 + 标记定义注册表 + **标记标注系统**）
> doc_status: active  
> last_reviewed: 2026-02-17

---

## 1. 系统愿景

**场景蓝图（SceneBlueprint）** 是一套基于 NodeGraph 框架的可视化场景编排系统，用于在 Unity 编辑器中以节点图的方式编排场景内的一切事件——战斗、环境变化、摄像机控制、特效、叙事等。

核心理念：**Everything is an Action**——场景中每一个可执行的行为都是一个"行动"节点，通过连线表达执行顺序和条件关系。

### 1.1 设计哲学

借鉴 UE GAS（Gameplay Ability System）的核心哲学，但针对"场景编排"而非"实体能力"重新定义：

| GAS 哲学 | 场景蓝图的体现 |
|----------|--------------|
| 数据驱动 | 行动类型通过 ActionDefinition 数据声明，非硬编码 |
| 组合优于继承 | 复杂行为通过图的拓扑组合表达，而非单个巨型节点 |
| 标签驱动条件 | Tag 系统用于条件匹配、行动筛选、事件过滤 |
| 表现与逻辑分离 | Camera/VFX/Audio 作为独立 Action 类型编排 |

### 1.2 与 GAS 的区别

```
GAS (Gameplay Ability System)           SceneBlueprint
──────────────────────────              ──────────────────────────
以"实体"为中心                          以"场景/关卡"为中心
"角色能做什么"                          "场景里会发生什么"
Entity → owns → Abilities              Scene → contains → Actions
运行时动态触发（玩家按键、受击）          编辑时预编排 + 运行时条件触发
```

---

## 2. 系统命名与范围

**系统名：SceneBlueprint（场景蓝图）**

范围：场景内一切可编排的事件。具体用途实例包括：
- 战斗蓝图（刷怪、Boss 战、增援）
- 环境蓝图（灯光、天气、地形变化）
- 叙事蓝图（对话、过场、任务提示）

命名选择理由：
- "Scene" 足够宽——战斗、灯光、天气、过场都是场景内事件
- "Blueprint" 保持与 UE 的概念对齐
- 未来可以有 CombatBlueprint、EnvironmentBlueprint、NarrativeBlueprint 等具体用途，共享同一套框架

---

## 3. GAS 概念映射

| GAS 概念 | 场景蓝图概念 | 说明 | 阶段 |
|----------|------------|------|------|
| GameplayAbility | **Action（行动）** | 一个可执行单元 | Phase 1 ✅ |
| GameplayTag | **Tag（标签）** | 层级化条件标签 | Phase 1 ✅ |
| GameplayEvent | **Event（事件）** | 通知/触发信号 | Phase 1 ✅ |
| AbilitySystemComponent | **BlueprintRunner** | 蓝图执行器 | Phase 1 ✅ |
| — | **Transition（过渡）** | 带条件的连线 | Phase 1 ✅ |
| — | **ActionDefinition** | 行动类型声明 | Phase 1 ✅ |
| — | **SceneBinding（场景绑定）** | 节点 ↔ 场景对象 | Phase 1 ✅ |
| AttributeSet | **Blackboard（黑板）** | 蓝图级共享变量 | ❌ 暂缓 |
| GameplayEffect | **Effect（效果）** | 对世界的持续修改 | ❌ 暂缓 |
| GameplayCue | **Cue（表现）** | 表现层反馈 | ❌ 暂缓 |
| AbilityTask | —（不需要） | NodeGraph 天然支持异步流程 | — |

### 3.1 为什么暂缓 Blackboard？

图的拓扑结构本身就是"程序"。Blackboard 本质上是给"没有图结构"的系统（如 GAS 的扁平 Ability 列表）提供状态传递能力。我们有图——节点间的连线和端口天然就是状态流动的通道。

替代方案：

| 替代机制 | 覆盖场景 |
|---------|---------|
| Action 多输出端口 | 行动自身的状态变化（onComplete / onFail / onHP50%） |
| Transition 条件 | 时间延迟、事件触发（Delay(3s) / Event("xxx")） |
| Flow 节点（Counter/Join/Branch） | 跨行动的聚合逻辑 |
| 蓝图级静态参数 | 全局配置（导出时确定，非运行时变量） |

如果将来确实遇到"必须在运行时跨行动共享动态状态"的场景，再引入 Blackboard——它是附加层，不影响已有机制。

---

## 4. 三层架构

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│   Layer 3: Game-Specific Actions（游戏特定行动）                  │
│   ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐          │
│   │  Spawn   │ │   Trap   │ │  Camera  │ │  Light   │  ...     │
│   │  Action  │ │  Action  │ │  Action  │ │  Action  │          │
│   └────┬─────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘          │
│        │ register    │            │             │                 │
│   ─────┼─────────────┼────────────┼─────────────┼─────────────   │
│        ▼             ▼            ▼             ▼                 │
│   Layer 2: SceneBlueprint SDK                                    │
│   ┌────────────────────────────────────────────────────────┐    │
│   │  ActionRegistry  ← ActionDefinition[]                   │    │
│   │  PropertySystem  ← PropertyDefinition[] + PropertyBag   │    │
│   │  TagSystem       ← hierarchical tags + conditions       │    │
│   │  Transition      ← condition expressions                │    │
│   │  BlueprintAsset  ← serialization                        │    │
│   │  BlueprintExporter ← 将图编译为运行时数据               │    │
│   │  InspectorGen    ← auto-generate property UI            │    │
│   └────────────────────────────────────────────────────────┘    │
│        │ depends on                                              │
│   ─────┼───────────────────────────────────────────────────────  │
│        ▼                                                         │
│   Layer 1: NodeGraph Framework                                   │
│   ┌────────────────────────────────────────────────────────┐    │
│   │  Graph / Node / Edge / Port                             │    │
│   │  Rendering (IMGUI 纯矢量)                               │    │
│   │  Layout / Interaction / Selection                        │    │
│   │  Serialization                                           │    │
│   └────────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 4.1 三方模型：Editor / Data / Runtime

核心约束：**编辑器和运行时不在同一个项目**。蓝图编辑器输出纯数据，运行时（帧同步引擎）消费数据。

```
┌─────────────────────────┐          ┌─────────────────────────┐
│   Unity Editor 项目      │          │   运行时项目             │
│   (当前工程)             │   导出    │   (帧同步引擎)           │
│                         │ ═══════► │                         │
│  · NodeGraph Framework  │  数据文件  │  · 帧同步逻辑            │
│  · SceneBlueprint SDK   │          │  · 战斗系统              │
│  · 可视化编辑器          │          │  · 怪物系统              │
│  · 不参与运行时          │          │  · 不知道 Unity          │
│                         │          │  · 不知道 NodeGraph      │
└─────────────────────────┘          └─────────────────────────┘
```

这意味着：
1. 蓝图的可视化图（节点/连线）是纯编辑器概念，运行时从来看不到
2. 运行时看到的是一份纯数据——行动列表 + 条件关系 + 属性参数
3. 运行时有自己的 ActionHandler 实现，和编辑器的 ActionDefinition 独立
4. 导出步骤是桥梁，负责把"图"编译成"数据"

---

## 5. 行动类型分类体系

按功能域分组：

```
┌─ Combat（战斗域）
│   ├─ PlacePreset    放置预设怪（瞬时，固定位置）
│   ├─ Spawn          节奏刷怪（持续，多波次）
│   ├─ PathSpawn      行进间刷怪（路径绑定）
│   ├─ BossPhase      Boss 阶段切换
│   ├─ Trap           陷阱激活/布置
│   ├─ Hazard         环境危害（毒雾、地刺）
│   └─ Buff           全局 Buff/Debuff
│
├─ Presentation（表现域）
│   ├─ Camera         摄像机控制（推拉摇移、震动、慢动作）
│   ├─ VFX            视觉特效
│   ├─ Audio          音频/音乐
│   └─ UI             UI 提示/文字
│
├─ Narrative（叙事域）
│   ├─ Dialogue       对话
│   ├─ Cutscene       过场动画
│   └─ Objective      任务目标提示
│
├─ Environment（环境域）
│   ├─ TerrainChange  地形变化（桥断裂、墙倒塌）
│   ├─ LightChange    光照变化
│   └─ Weather        天气变化
│
└─ Flow（流程域）← 蓝图内置
    ├─ Start          起点
    ├─ End            终点
    ├─ Delay          延迟
    ├─ Branch         条件分支
    ├─ Join           汇合
    ├─ Loop           循环
    ├─ Random         随机选择
    └─ SubBlueprint   子蓝图引用
```

### 5.1 Action 生命周期

```
Action 生命周期：
  Inactive → Activated → Running → Completed / Cancelled

Action 时间分类：
  瞬时行动 (Instant)  — 执行一次就完成（放置预设怪、切换灯光）
  持续行动 (Duration)  — 持续一段时间（节奏刷怪、摄像机跟踪、毒雾区域）
  被动行动 (Passive)   — 条件满足时自动响应（玩家进入区域时…）
```

### 5.2 与旧 SpawnTask 的对比

旧系统的 `SpawnTask` 是一个"巨型"对象，包含 12+ 个配置字段。新系统彻底拆解：

| 旧 SpawnTask 字段 | 新系统中谁承担 |
|-------------------|--------------|
| TriggerConfig | 图的连线 + Transition 条件 |
| DependsOn[] | 图的拓扑结构（连线天然表达依赖） |
| CompletionConfig | Action 输出端口 → 连到下一个节点 |
| MonsterGroupTemplate | SpawnAction 的 `template` 属性 |
| PlacementConfig | SpawnAction 的属性 + 场景绑定 |
| TempoConfig | SpawnAction 的 `tempo` 属性组 |
| ConstraintConfig | SpawnAction 的 `constraint` 属性组 |
| BehaviorOverride | SpawnAction 的属性（或独立 Modifier 节点） |

**Task 概念已废弃**——取而代之的是"图的拓扑 + Action 属性"的组合。

### 5.3 战斗域行动类型详情

| 行动类型 | 说明 | 权重 | 关键属性 | 输出端口 |
|---------|------|------|---------|---------|
| **PlacePreset** | 放置预设怪 | 轻 | template, sceneBinding | out |
| **Spawn** | 节奏刷怪 | 中 | template, tempo, area, constraints | out, onWaveComplete, onAllComplete |
| **PathSpawn** | 行进间刷怪 | 中 | template, path, triggerDistance | out, onPointTriggered, onAllComplete |
| **BossPhase** | Boss 阶段 | 重 | bossId, phase, hpThresholds | out, onHP*%（动态端口） |

---

## 6. 蓝图粒度

### 6.1 一个场景多张蓝图

每张蓝图 = 一个"遭遇"（Encounter），自包含，有自己的 Start 和结束。

```
地宫关卡场景
├─ 蓝图 A: "走廊伏击"        （行进间刷怪，~5 个节点）
├─ 蓝图 B: "房间A清场"       （一波刷怪，~3 个节点）
├─ 蓝图 C: "房间B遭遇战"     （多波 + 增援，~8 个节点）
├─ 蓝图 D: "Boss战"          （多阶段 + 增援 + 摄像机，~15 个节点）
└─ 蓝图 E: "逃脱序列"        （环境 + 追兵，~6 个节点）
```

每张蓝图推荐 **3~15 个节点**。

### 6.2 蓝图间衔接

蓝图之间不直接连线，衔接由游戏关卡逻辑管理：

```
关卡逻辑：
  玩家进入走廊 → 激活蓝图A
  蓝图A完成    → 开门 → 玩家进入房间A → 激活蓝图B
  蓝图B完成    → 开门 → Boss房 → 激活蓝图D
```

### 6.3 两层数据模型

蓝图系统采用**两层数据模型**——编辑层使用 ScriptableObject（SO），运行时层使用 JSON：

```
┌─────────────────────────────────────────────────────────────┐
│  第 1 层：编辑器数据（Unity 序列化）                           │
│                                                              │
│  BlueprintAsset (ScriptableObject)                           │
│  ├─ 一个关卡 = 一个 SO                                       │
│  ├─ 图数据（节点、连线、子蓝图框、属性值）                     │
│  ├─ 元信息（名称、版本）                                      │
│  └─ Unity Inspector 可查看摘要信息                            │
│                                                              │
│  SceneBlueprintManager (MonoBehaviour, 场景中唯一)            │
│  ├─ blueprintAsset ← 引用整个关卡的 SO                       │
│  ├─ bindings (按子蓝图 ID 分组)                               │
│  │   ├─ "子蓝图A" → { spawnArea: [GameObject], ... }         │
│  │   └─ "子蓝图B" → { bossSpawn: [GameObject], ... }         │
│  └─ 由编辑器自动管理，策划无需直接操作                         │
│                                                              │
├────────────────── 导出边界 ──────────────────────────────────┤
│                                                              │
│  第 2 层：运行时数据（JSON / Binary）                          │
│                                                              │
│  SceneBlueprintData (JSON)  ← 从 SO + Manager 合并生成       │
│  ├─ 所有 Unity 引用已解析为字符串 ID / 坐标数值               │
│  ├─ 零 Unity 依赖                                            │
│  └─ 运行时（帧同步引擎）直接消费                               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**设计动机：**

| 问题 | SO 层如何解决 | JSON 层如何解决 |
|------|-------------|----------------|
| 资产引用（怪物预制体） | 在 Inspector 中拖入 | 导出时解析为字符串 ID |
| 场景绑定（刷怪区域） | 在编辑器 Inspector 面板中拖入 | 导出时解析为坐标数组 |
| 关卡结构 | 子蓝图折叠/展开可视化编排 | 导出为平坦的 Action 列表 |
| 运行时跨项目 | N/A（编辑器专用） | 零 Unity 依赖 |

### 6.4 子蓝图与关卡结构

**一个关卡 = 一张图**，通过 NodeGraph 的 SubGraphFrame（子蓝图）组织内部结构。

#### 子蓝图概念

子蓝图是 NodeGraph 框架原生支持的容器机制（SubGraphFrame），在 SceneBlueprint 中用作：
- **逻辑分组**——将相关的行动节点打包在一起（如"走廊战斗"、"灯光氛围"、"Boss演出"）
- **编排单元**——子蓝图之间通过边界端口连线，表达触发和衔接关系
- **视图控制**——折叠时看全局流程，展开时看内部细节

术语说明：**"子蓝图"是通用名词，策划通过标题自定义含义**。系统不预设"幕"、"阶段"等特定语义。

#### 折叠视图（全局流程总览）

```
┌──────────────────────────────────────────────────────────┐
│                                                          │
│  [关卡开始]──►[📦走廊战斗]──完成──►[📦Boss战]             │
│                   │              ├─Boss逃跑─►[📦追击]    │
│                   └─发现密道─►[📦密室宝藏]───►┘           │
│                                         ───►[关卡结束]   │
│                                                          │
│  📦 = 折叠的子蓝图（RepresentativeNode）                  │
│  看起来就是普通节点，有输入/输出端口                       │
└──────────────────────────────────────────────────────────┘
```

每个折叠的子蓝图显示为紧凑节点：
```
┌───────────────────────┐
│  📦 走廊战斗           │
│  ──────────────────── │
│  ● 激活          完成 ●│
│               发现密道 ●│
└───────────────────────┘
```

#### 展开视图（子蓝图内部细节）

```
┌──────────────────────────────────────────────────────┐
│  [关卡开始]──►┐                        ┌──完成──►... │
│               │                        │             │
│  ┌────────────┼── 走廊战斗 ────────────┼───────────┐ │
│  │ ▼          │                        │           │ │
│  │  ● 激活    ▼                        ▲   完成 ●  │ │
│  │       [放置预设怪]→[条件分支]─T→[刷怪]→[汇合]    │ │
│  │                        └─F→[延迟]──→┘           │ │
│  │                                      发现密道 ● │ │
│  └─────────────────────────────────────────────────┘ │
│                                   │                   │
│  [📦Boss战]◄──────────────────────┘                   │
└──────────────────────────────────────────────────────┘
```

展开时：
- 内部节点全部可见可编辑
- **边界端口定位到框边缘**（`● 激活` 在左，`完成 ●` 在右）
- RepresentativeNode 本身隐藏，顶层连线自然连到框边缘端口
- 其他子蓝图保持折叠，不干扰视野

#### 边界端口（方案 β）

子蓝图不使用内部的 Start/End 节点作为入口出口，**直接用框边缘的边界端口**：
- 边界输入端口 `● 激活`：顶层连线连入，内部第一个节点直接连到此端口
- 边界输出端口 `完成 ●` / `发现密道 ●`：内部最后一个节点连到此端口

策划可以添加多个出口端口表示不同结局（如"Boss死亡"、"Boss逃跑"），在顶层连到不同的后续子蓝图。

#### 顶层混合使用

顶层不仅限于子蓝图节点，也可以混合简单的 Action 节点：
```
[关卡开始] → [📦走廊战斗] → [延迟 3s] → [播放过场动画] → [📦Boss战]
                                 ↑ 普通 Action 节点（"胶水逻辑"）
```

#### 子蓝图设计规则（2026-02-13 确认）

##### 规则 1：禁止嵌套，只允许单层子图

作用域只有两层：**根级** + **一层子蓝图**。`GroupNodesCommand` 过滤三类节点：
- `Flow.Start` / `Flow.End`（全局入口出口，不可编入子蓝图）
- 已属于其他子蓝图的节点（禁止嵌套）
- `RepresentativeNode`（边界节点本身）

如果过滤后无剩余节点，操作取消。

##### 规则 2：连接策略（三种场景）

`DefaultConnectionPolicy` 按三种场景分别处理连接校验：

| 场景 | 描述 | 校验规则 |
|------|------|---------|
| **A) 内部桥接** | 边界端口 ↔ 同子蓝图内节点 | 豁免方向/容量校验，仅检查 Kind + DataType + 重复 |
| **B) 外部连接** | 外部节点 ↔ 边界端口 | 普通方向校验，但边界端口跳过容量检查 |
| **C) 普通连接** | 同作用域内两个普通节点 | 完整校验（方向 + Kind + DataType + 重复 + 容量 + 环检测） |

**跨作用域的普通连接被拒绝**——所有跨界流量必须经过边界端口。`GetContainingFrameId` 用于判断节点所属作用域。

##### 规则 3：边界端口推断（InferBoundaryPorts）

框选打组时自动分析跨界连线，按 `(方向, Kind, DataType)` 合并为单个边界端口：
- 多条同类 Output 跨界边 → 合并为一个"完成"端口
- 多条同类 Input 跨界边 → 合并为一个"激活"端口
- 始终保证有 Input（激活）和 Output（完成）边界端口，缺少的自动补默认
- 外部段边去重：同一对 `(repPort, externalPort)` 只创建一条边

##### 规则 4：连线管理

- **端口右键菜单**：右键点击端口圆圈弹出菜单，列出该端口所有连线，可逐条或全部断开
- **连线可见性**：折叠子蓝图时隐藏内部连线，展开时边界端口连线正常渲染
- 操作支持 Undo（通过 `DisconnectCommand`）

##### 规则 5：Flow.Start 输出端口

`Flow.Start` 的输出端口使用 `EventOut`（Multiple 容量），允许并行触发多个初始行动节点。

#### 技术基础（NodeGraph 框架已有能力）

| 能力 | 实现 | 状态 |
|------|------|------|
| SubGraphFrame 容器 | `GraphDecoration.SubGraphFrame` | ✅ 已有 |
| 折叠/展开交互 | `ToggleSubGraphCollapseCommand` + `DecorationInteractionHandler` | ✅ 已有 |
| 代表节点 + 边界端口 | `RepresentativeNode`（TypeId `__SubGraphBoundary`） | ✅ 已有 |
| 展开时端口重定位 | `BaseFrameBuilder.BuildBoundaryPorts` | ✅ 已有 |
| 从模板实例化子蓝图 | `SubGraphInstantiator` + `CreateSubGraphCommand` | ✅ 已有 |
| JSON 序列化 | `JsonGraphSerializer` 完整支持 SubGraphFrame | ✅ 已有 |
| 打组 + 边界端口推断 | `GroupNodesCommand` + `InferBoundaryPorts` | ✅ 新增 |
| 解散子蓝图 | `UngroupSubGraphCommand` | ✅ 新增 |
| 连接策略 | `DefaultConnectionPolicy`（三场景 + 作用域检查） | ✅ 新增 |
| 端口右键菜单 | `ContextMenuHandler` → `OnPortContextMenuRequested` | ✅ 新增 |

### 6.5 场景绑定与编辑器 UX

#### 一站式编辑体验

蓝图编辑器是策划的**唯一操作入口**。SceneBlueprintManager 降级为"自动管理的后端存储"，策划无需直接接触。

```
┌──────────────────────────────────────────────────────────────────┐
│ 场景蓝图编辑器 - 关卡31                                          │
├──────────────────────────────────────────────────────────────────┤
│ [新建] [保存] [加载] │ [+ 子蓝图] [全部折叠] [全部展开] │ [同步] │
├────────────────────────────────┬─────────────────────────────────┤
│                                │ Inspector                        │
│          画布区域               │   (根据选中对象动态变化)          │
│    (折叠/展开子蓝图)            │                                  │
├────────────────────────────────┴─────────────────────────────────┤
│ 📍 顶层 │ 子蓝图: 3 │ 节点: 21 │ 绑定: 4/5 ⚠️ │ 已修改*          │
└──────────────────────────────────────────────────────────────────┘
```

#### Inspector 面板动态切换

**选中 Action 节点时**：显示属性编辑 + SceneBinding 直接拖入场景对象

**选中折叠的子蓝图时**：显示子蓝图摘要 + 边界端口管理 + 所有绑定汇总

**未选中任何对象时**：显示关卡总览 + 全部未绑定项一览

#### 数据流

```
保存时：
  图数据（含子蓝图框）───► BlueprintAsset.GraphJson (SO)
  绑定数据 ──────────────► SceneBlueprintManager (场景中，按子蓝图ID分组)

加载时：
  BlueprintAsset.GraphJson ──► 反序列化为 Graph（含子蓝图框）
  Manager.Bindings ──────────► 恢复到编辑器 Inspector 的 ObjectField

导出时：
  SO 图数据 + Manager 绑定数据 ──► SceneBlueprintData (JSON)
```

### 6.6 多张 vs 一张大蓝图

通过子蓝图机制，兼得两者优势：

| 维度 | 一张大蓝图（旧问题） | 子蓝图方案 |
|------|-------------------|-----------|
| **可读性** | 节点多时变蜘蛛网 | 折叠子蓝图后仅显示编排流程 |
| **组织性** | 平坦结构难以管理 | 按逻辑分组，每个子蓝图 3~15 节点 |
| **全局视野** | 需要缩放到很小才能总览 | 全部折叠 = 清晰的流程图 |
| **编排能力** | 无法表达子蓝图间的触发关系 | 顶层连线 = 可视化编排 |
| **复用** | N/A | 通过 SubGraphInstantiator 拷贝模板 |
| **场景绑定** | 与图编辑割裂 | Inspector 面板原地绑定 |

---

## 7. 编排模式示例

### 7.1 基础：顺序执行

```
[Start] → [Spawn "第1波"] → [Spawn "第2波"] → [End]
```

### 7.2 预设怪 + 触发刷怪

```
[Start] ─────────────→ [PlacePreset "巡逻精英"]
   │
   │  Event("enter_boss_room")
   └──────────────────→ [Spawn "小怪第1波"] ──onAllComplete──→ [BossPhase 1]
```

### 7.3 增援（不等打完）

```
[Start] → [Spawn "主力" waves:3]
               │
               │ onWaveComplete ──Delay(5s)──→ [Spawn "增援" "从侧翼包抄"]
               │
               │ onAllComplete ──→ ...
```

### 7.4 Boss 战多阶段

```
[Start] → [Spawn "前哨"] ──onAllComplete──→ [BossPhase 1 boss:魔王]
                                                │ onHP50% → [Spawn "增援1"]
                                                │ onHP20% → [BossPhase 2 "狂暴"]
```

### 7.5 行进间刷怪

**方式 A：多触发点 + 多 Spawn**

```
[Start] ─Event("reach_point_1")─→ [Spawn "伏兵1"]
   │    ─Event("reach_point_2")─→ [Spawn "伏兵2"]
   │    ─Event("reach_point_3")─→ [Spawn "伏兵3"]
```

**方式 B：PathSpawn 封装**

```
[Start] ─Event("enter_corridor")─→ [PathSpawn path:"corridor_01" triggerDist:15m]
```

### 7.6 编排模式总结

| 编排模式 | 图表达方式 |
|---------|-----------|
| 顺序执行 | A → B → C（线性连接） |
| 并行执行 | A 同时连到 B 和 C（分叉） |
| 增援/追加 | A.onWaveComplete → B（中间端口分叉） |
| 条件分支 | A.onHP50% → B，A.onHP20% → C（多输出端口） |
| 延迟触发 | A → Delay(5s) → B |
| 事件触发 | Start → Event("xxx") → B（连线条件） |
| 循环刷怪 | A.onAllComplete → Delay(10s) → A（回环连线） |

---

## 8. 技术依赖

| 层级 | 依赖 | 数据格式 |
|------|------|---------|
| SceneBlueprint SDK | NodeGraph Framework（Core / View / Commands / Serialization） | — |
| Game Actions（Layer 3） | SceneBlueprint SDK + 游戏业务层 | — |
| 编辑器持久化 | Unity ScriptableObject | BlueprintAsset (.asset) |
| 场景配置 | Unity MonoBehaviour（SceneBlueprintManager） | Scene 序列化 |
| 运行时 | 仅依赖导出的数据格式，不依赖 Unity / NodeGraph | JSON / Binary |

---

## 9. 实施路线（概览）

### 9.1 阶段总览

| 阶段 | 内容 | 依赖 | 测试里程碑 |
|------|------|------|-----------|
| **Phase 1** ✅ | ActionDefinition + ActionRegistry + PropertySystem | NodeGraph Framework | 纯代码单元测试全通过 |
| **Phase 2** ✅ | 蓝图编辑器窗口 + Inspector 面板 | Phase 1 | 编辑器中可创建/编辑蓝图，Inspector 属性编辑 |
| **Phase 3** ✅ | 数据导出（BlueprintExporter → SceneBlueprintData） | Phase 1 | 导出 JSON 并人工确认结构正确 |
| **Phase 4** | 蓝图持久化 + 子蓝图编排 + 场景绑定（BlueprintAsset SO + 子蓝图 UX + Manager 自动管理） | Phase 2 + 3 | 蓝图保存/加载，子蓝图折叠/展开，Inspector 原地绑定，导出 JSON |
| **Phase 5** | Tag 系统集成 | Phase 1 | Tag 条件过滤正确 |
| **Phase 6** | AI Director（基础） | Phase 3（运行时侧） | Director 可返回范围内建议值 |
| **Phase 7** | AI Director（完整 Utility AI） | Phase 6 | 情绪曲线驱动决策 |

### 9.2 测试策略

每个 Phase 完成后必须通过**两层验证**才能进入下一阶段：

```
第一层：单元测试（自动化）
  位置：Assets/Extensions/SceneBlueprint/Tests/
  框架：Unity Test Framework (NUnit)
  运行：Unity Editor → Window → General → Test Runner → EditMode
  要求：每个 Phase 的核心类都有对应测试，全部 Pass

第二层：编辑器冒烟测试（手动，< 2 分钟）
  通过编辑器窗口或 MenuItem 快速执行一个端到端验证
  每个 Phase 提供一个一键验证入口
```

### 9.3 分阶段测试检查点

#### Phase 1 检查点：Action 与属性系统

```
单元测试：
  ✅ ActionDefinition 可正确创建，属性/端口声明完整
  ✅ ActionRegistry 注册、查找、按分类过滤正常
  ✅ AutoDiscover 能扫描到 [ActionType] 标注的类
  ✅ PropertyBag 存取各类型值（float/int/bool/string/enum）正确
  ✅ ActionNodeData 从 Definition 创建时默认值正确
  ✅ PropertyBag JSON 序列化/反序列化往返一致
  ✅ Prop 工厂方法生成的 PropertyDefinition 字段正确
  ✅ VisibleWhen 条件评估器对基本表达式返回正确布尔值

冒烟测试（MenuItem）：
  → 调用 ActionRegistry.AutoDiscover()
  → 打印所有已注册 Action 类型和属性列表到 Console
  → 创建一个 SpawnAction 的 ActionNodeData，设置属性，序列化为 JSON，再反序列化，断言一致
```

#### Phase 2 检查点：蓝图编辑器窗口 ✅（2026-02-13 完成）

```
冒烟测试（编辑器窗口）：
  ✅ 打开蓝图编辑器（Alt+B / 菜单 SceneBlueprint/蓝图编辑器）
  ✅ 右键画布空白区域弹出分类添加节点菜单
  ✅ 右键节点弹出上下文菜单（删除节点等）
  ✅ 创建节点后画布正确渲染（标题、端口、摘要文本）
  ✅ 连线操作正常（端口拖拽）
  ✅ 画布裁剪正确（节点不超出工具栏区域）
  ✅ 选中节点 → 右侧 Inspector 面板显示完整属性编辑控件
  ✅ 在 Inspector 修改属性 → 画布摘要文本实时更新
  ✅ 画布缩放/平移下节点显示正常（摘要模式不受缩放影响）
  ✅ 分栏条可拖拽调整 Inspector 宽度
```

##### Phase 2 架构决策记录

**决策 1：上下文菜单 — 混合架构**
- 框架层 `ContextMenuHandler` 检测右键事件，触发 `GraphViewModel` 回调
- 三种右键目标：画布空白（`OnContextMenuRequested`）、节点（`OnNodeContextMenuRequested`）、端口（`OnPortContextMenuRequested`）
- 端口右键菜单支持逐条/全部断开连线
- 宿主窗口订阅回调，使用 Unity `GenericMenu` 展示菜单
- 职责分离：框架决定"何时"，宿主决定"如何"

**决策 2：画布裁剪 — Zero-Matrix + BeginClip**
- `GUI.matrix` 保持 identity，所有坐标通过 `C2W()` 手动转换
- `GUI.BeginClip(graphRect)` 在 Repaint 事件中裁剪，`screenOffset = Vector2.zero`

**决策 3：节点属性编辑 — Inspector 外置面板（非内嵌编辑）**
- 问题：EditorGUI 内嵌编辑控件在 Zero-Matrix 缩放模式下无法正确缩放
- 方案：右侧 Inspector 面板使用 `EditorGUILayout` 自动布局，不受缩放影响
- `INodeInspectorDrawer` 接口放在 `NodeGraph.Unity` 层（平台相关）
- `INodeContentRenderer`（画布摘要）与 `INodeInspectorDrawer`（面板编辑）职责分离

**决策 4：窗口布局 — 内嵌分栏（Canvas | Splitter | Inspector）**
- 可拖拽分栏条（200~500px）
- 输入事件仅在画布区域内响应

##### Phase 2 新增文件清单

| 文件 | 层级 | 职责 |
|------|------|------|
| `NodeGraph/View/Handlers/ContextMenuHandler.cs` | 框架 | 右键事件检测与回调 |
| `NodeGraph/Unity/INodeInspectorDrawer.cs` | 框架(Unity) | Inspector 绘制器接口 |
| `NodeGraph/Unity/InspectorPanel.cs` | 框架(Unity) | 面板基础设施 |
| `SceneBlueprint/Editor/SceneBlueprint.Editor.asmdef` | 业务 | 编辑器程序集 |
| `SceneBlueprint/Editor/ActionNodeTypeAdapter.cs` | 业务 | ActionDef → NodeTypeDef 桥接 |
| `SceneBlueprint/Editor/ActionContentRenderer.cs` | 业务 | 画布摘要渲染 |
| `SceneBlueprint/Editor/ActionNodeDataSerializer.cs` | 业务 | 节点数据序列化 |
| `SceneBlueprint/Editor/ActionNodeInspectorDrawer.cs` | 业务 | Inspector 属性编辑 |
| `SceneBlueprint/Editor/SceneBlueprintProfile.cs` | 业务 | 蓝图配置工厂 |
| `SceneBlueprint/Editor/SceneBlueprintWindow.cs` | 业务 | 编辑器窗口主体 |

#### Phase 3 检查点：数据导出 ✅（2026-02-13 完成）

```
冒烟测试（编辑器窗口"导出"按钮）：
  ✅ 创建包含 7 种节点类型的蓝图（Start/Branch/PlacePreset/Spawn/Delay/Join/End）
  ✅ 连线形成分支+汇合拓扑：Start→Branch→(PlacePreset|Spawn→Delay)→Join→End
  ✅ 点击"导出"按钮 → 选择保存路径 → 生成 JSON 文件
  ✅ JSON 结构完整：Actions(7)、Transitions(7)、BlackboardInit(空)
  ✅ 属性序列化正确：float/int/string/enum/assetRef 类型均正确导出
  ✅ 端口名称正确：输出/输入/True/False
  ✅ 验证规则生效：缺少 Start 节点 → Error，孤立节点 → Warning
```

##### Phase 3 架构决策记录

**决策 1：数据类零依赖**
- `SceneBlueprintData` 全家族数据类放在 `SceneBlueprint.Core.Export` 命名空间
- `noEngineReferences: true`，不引用 Unity/NodeGraph，运行时可直接消费

**决策 2：导出器在 Editor 层**
- `BlueprintExporter` 放在 `SceneBlueprint.Editor.Export`
- 依赖 `Graph`、`ActionRegistry` 等框架 API 完成遍历和属性提取

**决策 3：验证内置于导出流程**
- `ExportResult` 包含 `SceneBlueprintData` + `ValidationMessage[]`
- 4 条验证规则：Start 唯一性、TypeId 已注册、孤立节点、端口方向
- Error 级别阻止导出，Warning 级别允许导出但提示

**决策 4：JSON 序列化使用 JsonUtility**
- `BlueprintSerializer` 封装 `JsonUtility.ToJson/FromJson`
- 数据类使用 `[Serializable]` + 公共字段（兼容 JsonUtility 要求）

##### Phase 3 新增文件清单

| 文件 | 层级 | 职责 |
|------|------|------|
| `Core/Export/SceneBlueprintData.cs` | Core（零依赖） | 全家族纯数据类 |
| `Editor/Export/BlueprintExporter.cs` | Editor | 图→数据转换 + 验证 |
| `Editor/Export/BlueprintSerializer.cs` | Editor | JSON 序列化工具 |

##### 导出验证样例

导出文件：`Assets/GameAssets/SceneBlueprint/场景蓝图.json`

拓扑结构：
```
Start → Branch
  ├─ True  → PlacePreset ──→ Join → End
  └─ False → Spawn → Delay ─→ Join
```

#### Phase 4 检查点：蓝图持久化 + 子蓝图编排 + 场景绑定

Phase 4 分步实施（4A 已完成，4B~4C 按新设计推进）：

##### Phase 4A：BlueprintAsset (SO) + 蓝图保存/加载 ✅（2026-02-13 完成）

```
冒烟测试：
  ✅ 在蓝图编辑器中创建节点和连线
  ✅ 点击"保存"按钮 → 选择路径 → 生成 BlueprintAsset.asset 文件
  ✅ 关闭编辑器 → 重新打开 → 点击"加载" → 选择 .asset 文件
  ✅ 验证图数据完整恢复（节点数、连线数、属性值、节点颜色一致）
  ✅ Unity Inspector 中选中 .asset → 显示蓝图摘要信息（节点数、行动类型列表）
  ✅ Inspector 中点击"在蓝图编辑器中打开" → 直接加载到编辑器
```

##### Phase 4A 架构决策记录

**决策 1：Runtime 程序集**
- 新建 `SceneBlueprint.Runtime.asmdef`（`noEngineReferences: false`）
- `BlueprintAsset` (SO) 放在 Runtime 层（场景 Manager 需要引用）

**决策 2：BlueprintAsset 仅存 GraphJson 字符串**
- 图数据以 JSON 字符串存储在 SO 的 `GraphJson` 字段中
- 序列化/反序列化逻辑在 Editor 层（`JsonGraphSerializer`）
- SO 本身是纯数据容器，无业务逻辑

**决策 3：加载时重注册 NodeType**
- 反序列化的 Graph 拥有空的 NodeTypeRegistry
- 加载时使用 `existingGraph.Settings.NodeTypes` 注册 Action 类型
- 确保节点颜色和类型信息正确恢复

##### Phase 4A 新增文件清单

| 文件 | 层级 | 职责 |
|------|------|------|
| `Runtime/SceneBlueprint.Runtime.asmdef` | Runtime | Runtime 程序集定义 |
| `Runtime/BlueprintAsset.cs` | Runtime | 蓝图 ScriptableObject 数据容器 |
| `Editor/BlueprintAssetEditor.cs` | Editor | BlueprintAsset 自定义 Inspector |

##### Phase 4B：子蓝图编排 + Inspector 场景绑定 + 编辑器 UX

Phase 4B 分为两个子阶段：子蓝图交互（4B-1，已完成）和 Inspector + 绑定（4B-2，待实施）。

###### Phase 4B-1：子蓝图交互 ✅（2026-02-13 完成）

```
冒烟测试：
  ✅ 框选多个节点 → 右键"创建子蓝图" → 自动推断边界端口 + 重连跨界边
  ✅ Flow.Start / Flow.End 不可编入子蓝图（自动过滤）
  ✅ 已属于子蓝图的节点不可再打组（禁止嵌套）
  ✅ 折叠子蓝图 → 内部节点和连线隐藏 → Rep 节点显示边界端口
  ✅ 展开子蓝图 → 边界端口定位到框边缘 → 可拖拽连线
  ✅ 边界端口交互：悬停高亮、可拖拽连线
  ✅ 子蓝图外节点不能直接连到子蓝图内节点（作用域检查拒绝）
  ✅ 外部节点 ↔ 边界端口连接正常（断开后可重连）
  ✅ 右键端口 → 弹出菜单列出所有连线 → 可逐条/全部断开
  ✅ 右键 Rep 节点 → 展开/折叠子蓝图、解散子蓝图
  ✅ 双击折叠的 Rep 节点 → 展开子蓝图
  ✅ Delete 键删除选中节点
  ✅ 开始节点可并行连接多个后续节点（EventOut Multiple 容量）
```

Phase 4B-1 架构决策记录：

**决策 5：禁止嵌套子图（方案α）**
- 场景蓝图的规模不需要嵌套（10~30 节点，3~5 个子蓝图足够）
- 作用域只有两层（根级 + 一层子蓝图），规则简单、bug 少
- `GroupNodesCommand` 过滤已属于其他子蓝图的节点和 Rep 节点

**决策 6：连接策略三场景模型**
- `DefaultConnectionPolicy` 区分内部桥接 / 外部连接 / 普通连接
- `GetContainingFrameId` 判断节点所属作用域，跨作用域的普通连接被拒绝
- 边界端口在所有路径中跳过容量检查（同时承载内部+外部连线）
- `Graph.Connect` 同步判断：内部桥接跳过方向纠正和容量自动断开

**决策 7：边界端口推断合并策略**
- `InferBoundaryPorts` 按 `(方向, Kind, DataType)` 合并同类跨界边为单个端口
- 始终保证有"激活"（Input）和"完成"（Output）端口
- `ReconnectBoundaryEdges` 外部段边去重，避免重复连线

**决策 8：连线删除 — 端口右键菜单**
- 连线太细难以精确点击，改为右键端口显示连线管理菜单
- `ContextMenuHandler` 优先检测端口命中（14px 半径）
- 菜单列出该端口所有连线（显示对端节点名），支持逐条/全部断开

Phase 4B-1 新增/修改文件清单：

| 文件 | 层级 | 职责 |
|------|------|------|
| `NodeGraph/Commands/GroupNodesCommand.cs` | 框架 | 框选打组 + 边界端口推断 + 跨界边重连 |
| `NodeGraph/Commands/UngroupSubGraphCommand.cs` | 框架 | 解散子蓝图 |
| `NodeGraph/Core/DefaultConnectionPolicy.cs` | 框架 | 三场景连接策略 + 作用域检查 |
| `NodeGraph/Core/Graph.cs` | 框架 | Connect 方法支持边界端口桥接模式 |
| `NodeGraph/View/GraphViewModel.cs` | 框架 | 端口右键事件 + HitTestEdge 过滤隐藏节点 |
| `NodeGraph/View/Handlers/ContextMenuHandler.cs` | 框架 | 新增端口右键菜单检测 |
| `NodeGraph/View/Handlers/NodeDragHandler.cs` | 框架 | 双击 Rep 节点展开子蓝图 |
| `NodeGraph/View/Handlers/DecorationInteractionHandler.cs` | 框架 | 优先节点命中避免误拦截 |
| `NodeGraph/View/FrameBuilders/BaseFrameBuilder.cs` | 框架 | 边界端口悬停高亮 + 连线可见性判断 |
| `SceneBlueprint/Actions/Flow/FlowStartDef.cs` | 业务 | Start 输出改为 EventOut（Multiple） |
| `SceneBlueprint/Editor/SceneBlueprintWindow.cs` | 业务 | 端口右键菜单 + evt.Use() 修复点击延迟 |

###### Phase 4B-2：SceneMarker 体系 + Inspector 绑定 + 编辑器 UX ✅（2026-02-14 完成）

```
已完成步骤：
  ✅ S1. Inspector 面板增强：SceneBinding 属性显示 ObjectField，存 MarkerId
  ✅ S2. 工具栏 [+ 子蓝图] 按钮 → 创建空 SubGraphFrame
  ✅ S3. Inspector 状态切换：选中子蓝图时显示摘要 + 绑定汇总
  ✅ S4. Inspector 未选中时显示关卡总览 + 全部未绑定项
  ✅ S5. BindingContext 绑定上下文：编辑器内存维护，唯一真相源
  ✅ S6. [同步到场景] 按钮：绑定数据写入 Manager（自动创建）
  ✅ S7. 打开时从 Manager 恢复绑定（策略1: Manager 直接引用，策略2: MarkerId 查找）
  ✅ S8. [全部折叠/展开] 按钮
  ✅ S9. 状态栏：子蓝图数、绑定完成度

  ✅ S10. SceneMarker 组件体系（SceneMarker + PointMarker + AreaMarker + EntityMarker）
  ✅ S11. MarkerTypeIds 字符串常量 + MarkerRequirement（替代旧 MarkerType 枚举）
  ✅ S12. Gizmo 绘制管线（GizmoRenderPipeline + 3 Renderer，分阶段缓存）
  ✅ S13. SceneViewMarkerTool（Shift+右键菜单，Registry 驱动创建）
  ✅ S14. MarkerHierarchyManager（场景 Hierarchy 自动分组）
  ✅ S15. 图层系统 + 双向联动 + 绑定验证
  ✅ S16. MarkerDefinition + MarkerDefinitionRegistry（自动发现，零侵入扩展）
  ✅ S17. 绑定优化：PropertyBag 存 MarkerId、创建后自动绑定、MarkerId 恢复
  ✅ S18. SBLog 日志系统（分级 + 模块标签 + 环形缓冲 + 专用 EditorWindow）

冒烟测试：
  ✅ 选中含 SceneBinding 的节点 → Inspector 显示 ObjectField → 拖入场景对象
  ✅ 选中折叠的子蓝图 → Inspector 显示该子蓝图的所有绑定汇总
  ✅ 点击画布空白处 → Inspector 显示关卡总览 + 未绑定项
  ✅ 点击 [同步到场景] → 场景中自动创建/更新 SceneBlueprintManager
  ✅ 保存 → 重新打开 → 子蓝图框、绑定数据完整恢复
  ✅ Scene View 中 Shift+右键 → 选择 Action 类型 → 自动创建标记 + 蓝图节点 + 自动绑定
  ✅ 选中蓝图节点 → Scene View 高亮对应标记
  ✅ 选中场景标记 → 蓝图中高亮引用该标记的节点
```

Phase 4B-2 架构决策记录：

**决策 9：MarkerType 枚举 → MarkerTypeIds 字符串常量**
- 旧版 `MarkerType` 枚举（Point/Area/Entity）硬编码，新增类型必须改枚举 + 所有 switch
- 新版 `MarkerTypeIds` 字符串常量，开放式扩展，新增类型零侵入

**决策 10：标记定义注册表（方案B）**
- `MarkerDefinition` + `IMarkerDefinitionProvider` + `[MarkerDef]` + `MarkerDefinitionRegistry`
- 与 `ActionRegistry` 架构一致（自动发现 + 注册表模式）
- 新增标记类型只需添加 3 个文件，无需修改已有代码

**决策 11：PropertyBag 存 MarkerId 而非 GameObject.name**
- 旧版存 `name`，改名即断裂
- 新版存 `MarkerId`（GUID），稳定唯一，恢复时通过 `FindMarkerInScene(markerId)` 查找

**决策 12：创建标记后自动绑定**
- `OnMarkerCreated` 回调中，创建蓝图节点后立即写入 BindingContext + PropertyBag
- 消除手动拖拽步骤，一键完成"创建标记 → 创建节点 → 绑定"

**决策 13：SBLog 日志系统**
- `SBLogLevel`（Debug/Info/Warning/Error）+ `SBLogTags`（模块标签字符串常量）
- `SBLogBuffer` 环形缓冲 + `SBLogSettings` EditorPrefs 持久化
- `SBLogWindow` 专用 EditorWindow（过滤、搜索、导出）
- 所有 `Debug.Log` 调用已迁移到 `SBLog`

Phase 4B-2 新增文件清单：

| 文件 | 层级 | 职责 |
|------|------|------|
| `Core/MarkerType.cs` | Core | `MarkerTypeIds` 字符串常量类 |
| `Core/MarkerRequirement.cs` | Core | Action 场景需求声明（`string MarkerTypeId`） |
| `Runtime/Markers/SceneMarker.cs` | Runtime | 抽象基类（`abstract string MarkerTypeId`） |
| `Runtime/Markers/PointMarker.cs` | Runtime | 单点标记 |
| `Runtime/Markers/AreaMarker.cs` | Runtime | 区域标记（Polygon/Box） |
| `Runtime/Markers/EntityMarker.cs` | Runtime | 实体标记 |
| `Runtime/SceneBlueprintManager.cs` | Runtime | 场景持久化 Manager |
| `Runtime/SceneBindingSlot.cs` | Runtime | 单条绑定槽位 |
| `Runtime/SubGraphBindingGroup.cs` | Runtime | 子蓝图绑定分组 |
| `Editor/BindingContext.cs` | Editor | 编辑时绑定上下文 |
| `Editor/Logging/SBLog.cs` 等 7 文件 | Editor | 日志系统 |
| `Editor/Markers/Definitions/MarkerDefinition.cs` | Editor | 标记类型元数据 |
| `Editor/Markers/Definitions/IMarkerDefinitionProvider.cs` | Editor | Provider 接口 + Attribute |
| `Editor/Markers/Definitions/MarkerDefinitionRegistry.cs` | Editor | 自动发现注册表 |
| `Editor/Markers/Definitions/PointMarkerDef.cs` | Editor | Point Provider |
| `Editor/Markers/Definitions/AreaMarkerDef.cs` | Editor | Area Provider |
| `Editor/Markers/Definitions/EntityMarkerDef.cs` | Editor | Entity Provider |
| `Editor/Markers/Pipeline/GizmoRenderPipeline.cs` | Editor | Gizmo 管线 |
| `Editor/Markers/Pipeline/GizmoDrawContext.cs` | Editor | 绘制上下文 |
| `Editor/Markers/Pipeline/IMarkerGizmoRenderer.cs` | Editor | 渲染器接口 |
| `Editor/Markers/Pipeline/MarkerCache.cs` | Editor | 标记缓存 |
| `Editor/Markers/Pipeline/GizmoStyleConstants.cs` | Editor | 样式常量 |
| `Editor/Markers/Pipeline/GizmoLabelUtil.cs` | Editor | 标签工具 |
| `Editor/Markers/Renderers/PointMarkerRenderer.cs` | Editor | Point Renderer |
| `Editor/Markers/Renderers/AreaMarkerRenderer.cs` | Editor | Area Renderer |
| `Editor/Markers/Renderers/EntityMarkerRenderer.cs` | Editor | Entity Renderer |
| `Editor/Markers/MarkerLayerSystem.cs` | Editor | 图层系统 |
| `Editor/Markers/MarkerLayerOverlay.cs` | Editor | 图层面板 |
| `Editor/Markers/MarkerHierarchyManager.cs` | Editor | Hierarchy 分组 |
| `Editor/Markers/MarkerBindingValidator.cs` | Editor | 绑定验证 |
| `Editor/Markers/SceneViewMarkerTool.cs` | Editor | 右键菜单创建 |
| `Editor/Markers/SceneMarkerSelectionBridge.cs` | Editor | 双向联动 |

标记标注系统新增文件（2026-02-17）：

| 文件 | 层级 | 职责 |
|------|------|------|
| `Runtime/Markers/Annotations/MarkerAnnotation.cs` | Runtime | 标注抽象基类 |
| `Runtime/Markers/Annotations/InitialBehavior.cs` | Runtime | 怪物初始行为枚举 |
| `Runtime/Markers/Annotations/SpawnAnnotation.cs` | Runtime | 刷怪标注（MonsterId/Level/Behavior/GuardRadius） |
| `Runtime/Markers/Annotations/CameraAnnotation.cs` | Runtime | 摄像机标注（FOV/Transition/Easing） |
| `Editor/Markers/Annotations/AnnotationDefinition.cs` | Editor | 标注元数据 |
| `Editor/Markers/Annotations/IAnnotationDefinitionProvider.cs` | Editor | Provider 接口 + Attribute |
| `Editor/Markers/Annotations/AnnotationDefinitionRegistry.cs` | Editor | AutoDiscover 注册表 |
| `Editor/Markers/Annotations/Definitions/SpawnAnnotationDef.cs` | Editor | 刷怪标注定义 |
| `Editor/Markers/Annotations/Definitions/CameraAnnotationDef.cs` | Editor | 摄像机标注定义 |
| `Editor/Export/AnnotationExportHelper.cs` | Editor | Annotation 导出辅助 |
| `Core/Export/SceneBlueprintData.cs`（修改） | Core | 新增 AnnotationDataEntry |
| `Actions/Spawn/SpawnPresetDef.cs`（修改） | Actions | 双绑定槽（spawnArea + spawnPoints） |

##### Phase 4C：导出改造（从 SO + Manager 合并生成 JSON）

```
冒烟测试：
  → 在蓝图编辑器中点击 [导出] 按钮
  → 从 SO 读取图数据，从 Manager 读取绑定数据
  → 遍历所有子蓝图，提取 Action + SceneBinding
  → 验证导出的 JSON 包含完整的 SceneBindingEntry 数据
  → Area 类型绑定 → 导出顶点坐标数组
  → Transform 类型绑定 → 导出位置/旋转数据
  → 子蓝图间的编排关系 → 导出为顶层 Transition
```

##### Phase 4 工作流总览

```
策划日常编辑（一站式）：
  1. 打开场景 → 打开蓝图编辑器
  2. 用 [+ 子蓝图] 创建逻辑分组（战斗、灯光、演出等）
  3. 在子蓝图内添加节点 → Inspector 编辑属性 + 拖入场景对象
  4. 折叠子蓝图 → 在顶层编排触发关系
  5. 点击 [保存] → SO 存图数据，Manager 自动存绑定
  6. 点击 [导出] → 生成运行时 JSON

关键体验：
  - 策划全程在蓝图编辑器中操作，无需接触 Manager Inspector
  - 折叠 = 全局流程，展开 = 内部细节
  - Inspector 动态切换：节点属性 / 子蓝图汇总 / 关卡总览
```

#### Phase 5 检查点：Tag 系统

```
单元测试：
  ✅ Tag 层级解析正确（"Combat.Phase.2" → 三级路径）
  ✅ Tag 条件匹配：精确匹配、前缀匹配
  ✅ Transition 上的 Tag 条件评估正确

冒烟测试（MenuItem）：
  → 创建一组 Tag，执行匹配查询，打印结果
```

详细实施计划和每步测试用例见各子系统设计文档。

---

## 10. 相关文档

统一入口：[
文档导航](文档导航.md)

| 文档 | 状态 | 内容 |
|------|------|------|
| [Action与属性系统设计](Action与属性系统设计.md) | frozen | ActionDefinition、ActionRegistry、PropertyDefinition、Inspector 自动生成 |
| [SceneMarker系统设计](SceneMarker系统设计.md) | active | 场景标记组件、分层可视化、Scene View 右键创建、双向联动、Tag 集成 |
| [标记标注系统设计](标记标注系统设计.md) | active | MarkerAnnotation 组件化标注架构（Spawn/Camera）、Gizmo 集成、导出集成 |
| [节点激活语义与汇聚设计](节点激活语义与汇聚设计.md) | active | 节点激活规则（OR/AND）、Flow.Join 设计、业界方案对比、多路径汇聚 |
| [数据导出与运行时契约](数据导出与运行时契约.md) | frozen | SceneBlueprintData 格式、导出流程、运行时 Handler 接口 |
| [AI Director设计](_archive/AI%20Director设计.md) | deprecated | 历史 AI Director 方案（当前不实现） |
| [Gizmo绘制管线设计](Gizmo绘制管线设计.md) | frozen | 7阶段绘制管线、MarkerCache、IMarkerGizmoRenderer、视锥裁剪 |
| [数据驱动模板系统设计](_archive/数据驱动模板系统设计.md) | deprecated | 数据驱动模板草案（部分内容已过时） |

### 历史文档（旧刷怪系统，仅供参考）

位于 `Assets/Extensions/CombatBlueprint/Documents/`：
- ARPG怪物生成机制研究.md
- 自动战斗刷怪系统设计指南.md
- 怪物Tag体系设计.md
- 双层设计框架与预设编辑器集成.md
- 移除Recipe层优化方案.md
- 场景优先工作流设计.md
- 战斗蓝图编辑器设计文档.md
