# 数据导出与运行时契约

> 版本：v1.3  
> 日期：2026-02-13  
> 状态：Phase 4A 已完成，Phase 4B 设计完成（子蓝图 + 编辑器 UX）  
> 父文档：[场景蓝图系统总体设计](场景蓝图系统总体设计.md)
> doc_status: frozen  
> last_reviewed: 2026-02-15

---

## 1. 概述

本文档定义编辑器和运行时之间的**唯一契约**——导出数据格式 `SceneBlueprintData`。

核心约束：
- **零代码依赖**：数据层不引用 Unity、NodeGraph、SceneBlueprint SDK
- **可序列化**：JSON 格式（开发期），可选二进制（发布期）
- **自描述**：运行时不需要 ActionDefinition 就能理解数据结构
- **编辑器输出，运行时消费**：两方通过字符串约定（TypeId、PropertyKey）对齐

---

## 2. 数据模型

### 2.1 SceneBlueprintData（顶层）

```csharp
// 纯数据类，无任何框架依赖
public class SceneBlueprintData
{
    // ─── 元信息 ───
    public string BlueprintId;      // 蓝图唯一 ID
    public string BlueprintName;    // 蓝图名称
    public int Version;             // 数据版本号
    public string ExportTime;       // 导出时间戳

    // ─── 核心数据 ───
    public ActionEntry[] Actions;           // 行动表
    public TransitionEntry[] Transitions;   // 过渡表
    public VariableEntry[] BlackboardInit;  // 黑板初始值（Phase 2+，当前为空）
}
```

### 2.2 ActionEntry（行动条目）

```csharp
public class ActionEntry
{
    public string Id;               // 行动唯一 ID（来自图中节点 ID）
    public string TypeId;           // 行动类型，如 "Combat.Spawn", "Flow.Start"

    // 属性——扁平化键值对
    public PropertyValue[] Properties;

    // 场景绑定（可选）
    public SceneBindingEntry[] SceneBindings;
}
```

### 2.3 PropertyValue（属性值）

```csharp
public class PropertyValue
{
    public string Key;              // 属性键名，如 "template", "interval"
    public string ValueType;        // 值类型标识，如 "float", "int", "string", "assetRef"
    public string Value;            // 序列化后的值（字符串形式）
}
```

**为什么用 `string Value` 而不是类型化字段？**

1. 数据域不知道也不需要知道具体属性的语义——"interval" 到底是刷怪间隔还是灯光渐变时间，数据域不关心
2. 编辑器根据 PropertyDefinition 知道如何序列化/反序列化
3. 运行时根据 TypeId 知道如何解读属性——`ActionHandler["Combat.Spawn"]` 知道 "interval" 是 float
4. 字符串在 JSON 中天然友好，未来换二进制格式时加一层编码即可

### 2.4 TransitionEntry（过渡条目）

```csharp
public class TransitionEntry
{
    public string FromActionId;     // 来源行动 ID
    public string FromPortId;       // 来源端口，如 "out", "onComplete", "true"
    public string ToActionId;       // 目标行动 ID
    public string ToPortId;         // 目标端口，如 "in"

    // 条件（可组合）
    public ConditionData Condition;
}
```

### 2.5 ConditionData（条件数据）

```csharp
public class ConditionData
{
    public string Type;             // 条件类型：
                                    //   "Immediate"  — 立即触发
                                    //   "Delay"      — 延迟
                                    //   "Expression" — 表达式
                                    //   "Tag"        — 标签匹配
                                    //   "Event"      — 事件触发
                                    //   "AllOf"      — 全部满足（AND）
                                    //   "AnyOf"      — 任一满足（OR）

    public string Expression;       // 条件表达式：
                                    //   Delay:      "3.0"（秒数）
                                    //   Expression: "bossHP < 0.5"
                                    //   Tag:        "Combat.Phase.2"
                                    //   Event:      "player_enter_area"

    public ConditionData[] Children;// 组合条件的子条件（AllOf/AnyOf 时使用）
}
```

### 2.6 SceneBindingEntry（场景绑定条目）

```csharp
public class SceneBindingEntry
{
    public string BindingKey;       // 绑定键名，如 "spawnArea", "triggerArea", "targetLight"
    public string BindingType;      // 绑定类型，如 "Transform", "Area", "Path", "Collider"
    public string SceneObjectId;    // 场景对象标识（名字/路径/自定义 ID）
}
```

### 2.7 VariableEntry（变量条目，Phase 2+）

```csharp
public class VariableEntry
{
    public string Key;              // 变量名
    public string ValueType;        // "float", "int", "bool", "string"
    public string InitialValue;     // 初始值
}
```

---

## 3. 两层数据模型与导出流程

### 3.0 两层数据模型（Phase 4 架构决策）

蓝图系统采用两层数据架构：

```
┌─────────────────────────────────────────────────────────┐
│  第 1 层：编辑器数据（Unity 序列化）                       │
│                                                          │
│  BlueprintAsset (ScriptableObject)                       │
│  ├─ 一个关卡 = 一个 SO                                   │
│  ├─ 图数据（节点/连线/子蓝图框/属性，JSON 字符串）        │
│  ├─ 子蓝图 = SubGraphFrame（折叠/展开编排）               │
│  └─ 元信息（名称、版本）                                  │
│                                                          │
│  SceneBlueprintManager (MonoBehaviour, 场景中唯一)        │
│  ├─ blueprintAsset ← 引用整个关卡的 SO                   │
│  ├─ bindings（按子蓝图 ID 分组）                          │
│  │   ├─ "子蓝图A" → { spawnArea: GameObject, ... }       │
│  │   └─ "子蓝图B" → { bossSpawn: GameObject, ... }       │
│  └─ 由蓝图编辑器自动管理，策划无需直接操作                 │
│                                                          │
├───────────────── 导出边界 ────────────────────────────────┤
│                                                          │
│  第 2 层：运行时数据（零 Unity 依赖）                      │
│                                                          │
│  SceneBlueprintData (JSON)                               │
│  ├─ 所有 Unity 引用已解析为字符串/坐标                    │
│  ├─ 子蓝图展平为 Action + Transition                     │
│  └─ 运行时直接消费                                        │
└─────────────────────────────────────────────────────────┘
```

**关键原则：**
- 一个关卡一个 BlueprintAsset（SO），通过子蓝图组织内部结构
- 场景绑定在 Manager 中按子蓝图 ID 分组存储（策划通过编辑器 Inspector 面板拖入）
- 导出时合并：SO 图数据 + Manager 绑定数据 → 完整 JSON

### 3.1 导出流程

```
蓝图编辑器 [导出] 按钮
    │
    │ 读取 BlueprintAsset (SO)
    │   → 反序列化为 Graph 对象（含子蓝图框）
    │
    │ 读取场景中 SceneBlueprintManager
    │   → 按子蓝图 ID 获取绑定数据
    │
    │ BlueprintExporter.Export(graph, registry, bindings)
    │
    │ 步骤 1: 展平子蓝图，遍历所有节点
    │   顶层 Action 节点 → ActionEntry
    │   子蓝图内 Action 节点 → ActionEntry（带子蓝图来源标记）
    │   子蓝图边界端口 → 编排 Transition
    │
    │ 步骤 2: 遍历所有连线
    │   子蓝图内连线 → TransitionEntry
    │   子蓝图间连线 → 编排 TransitionEntry
    │
    │ 步骤 3: 解析场景绑定
    │   Manager.Bindings[子蓝图ID] → SceneBindingEntry[]
    │   Area 类型 → 提取顶点坐标数组
    │   Transform 类型 → 提取位置/旋转或字符串 ID
    │   Path 类型 → 提取路径点序列
    │
    │ 步骤 4: 验证
    │   · 子蓝图边界端口连通性
    │   · TypeId 已注册
    │   · 孤立节点
    │   · 场景绑定完整性
    │
    │ 步骤 5: 序列化
    │   SceneBlueprintData → JSON string
    │
    ▼
SceneBlueprintData (JSON)
    │
    │ 保存到文件
    ▼
Assets/GameAssets/SceneBlueprint/{场景名}/{蓝图名}.json
```

> **注意**：导出统一从蓝图编辑器发起。
> 快速导出（不含场景绑定）和完整导出（含场景绑定）都在编辑器窗口完成。

### 3.2 属性序列化规则

| PropertyType | ValueType 字符串 | Value 序列化方式 |
|-------------|-----------------|----------------|
| Float | `"float"` | `"2.5"` |
| Int | `"int"` | `"5"` |
| Bool | `"bool"` | `"true"` / `"false"` |
| String | `"string"` | 原始字符串 |
| Enum | `"enum"` | 枚举名字符串 `"Interval"` |
| AssetRef | `"assetRef"` | 资产标识字符串（如模板 ID `"elite_group_01"`） |
| Vector2 | `"vector2"` | `"1.5,2.0"` |
| Vector3 | `"vector3"` | `"1.5,2.0,3.0"` |
| Color | `"color"` | `"1.0,0.5,0.0,1.0"` (RGBA) |
| Tag | `"tag"` | Tag 路径 `"Combat.Phase.2"` |
| SceneBinding | — | 提升为 SceneBindingEntry，不在 Properties 中 |

### 3.3 AssetRef 特殊处理

编辑器中 AssetRef 存的是 Unity Object 引用（GUID）。导出时需要转换为运行时可识别的字符串标识：

```
编辑器中：MonsterGroupTemplate (UnityEngine.Object, GUID: abc123)
    ↓ 导出转换
运行时数据：{ Key: "template", ValueType: "assetRef", Value: "elite_group_01" }
```

转换策略由 `IAssetIdResolver` 接口定义：

```csharp
public interface IAssetIdResolver
{
    /// <summary>将 Unity 资产引用转换为运行时标识字符串</summary>
    string Resolve(UnityEngine.Object asset);
}
```

不同项目可以有不同的实现（用资产名、用配置表 ID、用路径等）。

---

## 4. 导出示例

### 4.1 简单的 Boss 战蓝图

```json
{
  "BlueprintId": "boss_room_01",
  "BlueprintName": "Boss房间战斗编排",
  "Version": 1,
  "ExportTime": "2026-02-12T10:30:00Z",
  "Actions": [
    {
      "Id": "start_1",
      "TypeId": "Flow.Start",
      "Properties": [],
      "SceneBindings": []
    },
    {
      "Id": "spawn_1",
      "TypeId": "Combat.Spawn",
      "Properties": [
        { "Key": "template", "ValueType": "assetRef", "Value": "elite_group_01" },
        { "Key": "tempoType", "ValueType": "enum", "Value": "Interval" },
        { "Key": "interval", "ValueType": "float", "Value": "2.0" },
        { "Key": "totalWaves", "ValueType": "int", "Value": "3" },
        { "Key": "monstersPerWave", "ValueType": "int", "Value": "5" }
      ],
      "SceneBindings": [
        { "BindingKey": "spawnArea", "BindingType": "Area", "SceneObjectId": "spawn_area_01" }
      ]
    },
    {
      "Id": "camera_1",
      "TypeId": "Presentation.Camera",
      "Properties": [
        { "Key": "action", "ValueType": "enum", "Value": "ZoomIn" },
        { "Key": "duration", "ValueType": "float", "Value": "1.5" }
      ],
      "SceneBindings": []
    },
    {
      "Id": "boss_phase1",
      "TypeId": "Combat.BossPhase",
      "Properties": [
        { "Key": "bossId", "ValueType": "assetRef", "Value": "boss_demon_king" },
        { "Key": "phase", "ValueType": "int", "Value": "1" }
      ],
      "SceneBindings": []
    }
  ],
  "Transitions": [
    {
      "FromActionId": "start_1",
      "FromPortId": "out",
      "ToActionId": "spawn_1",
      "ToPortId": "in",
      "Condition": { "Type": "Immediate", "Expression": null, "Children": null }
    },
    {
      "FromActionId": "spawn_1",
      "FromPortId": "onAllComplete",
      "ToActionId": "camera_1",
      "ToPortId": "in",
      "Condition": { "Type": "Immediate", "Expression": null, "Children": null }
    },
    {
      "FromActionId": "camera_1",
      "FromPortId": "out",
      "ToActionId": "boss_phase1",
      "ToPortId": "in",
      "Condition": { "Type": "Delay", "Expression": "2.0", "Children": null }
    }
  ],
  "BlackboardInit": []
}
```

### 4.2 带增援和事件触发的蓝图

```json
{
  "BlueprintId": "corridor_ambush",
  "BlueprintName": "走廊伏击",
  "Version": 1,
  "Actions": [
    { "Id": "start", "TypeId": "Flow.Start", "Properties": [] },
    {
      "Id": "spawn_main",
      "TypeId": "Combat.Spawn",
      "Properties": [
        { "Key": "template", "ValueType": "assetRef", "Value": "normal_group" },
        { "Key": "tempoType", "ValueType": "enum", "Value": "Interval" },
        { "Key": "interval", "ValueType": "float", "Value": "2.0" },
        { "Key": "totalWaves", "ValueType": "int", "Value": "3" },
        { "Key": "monstersPerWave", "ValueType": "int", "Value": "5" }
      ],
      "SceneBindings": [
        { "BindingKey": "spawnArea", "BindingType": "Area", "SceneObjectId": "corridor_area_01" }
      ]
    },
    {
      "Id": "spawn_flank",
      "TypeId": "Combat.Spawn",
      "Properties": [
        { "Key": "template", "ValueType": "assetRef", "Value": "elite_group" },
        { "Key": "tempoType", "ValueType": "enum", "Value": "Instant" },
        { "Key": "monstersPerWave", "ValueType": "int", "Value": "3" }
      ],
      "SceneBindings": [
        { "BindingKey": "spawnArea", "BindingType": "Area", "SceneObjectId": "flank_area_01" }
      ]
    }
  ],
  "Transitions": [
    {
      "FromActionId": "start", "FromPortId": "out",
      "ToActionId": "spawn_main", "ToPortId": "in",
      "Condition": { "Type": "Event", "Expression": "enter_corridor" }
    },
    {
      "FromActionId": "spawn_main", "FromPortId": "onWaveComplete",
      "ToActionId": "spawn_flank", "ToPortId": "in",
      "Condition": { "Type": "Delay", "Expression": "5.0" }
    }
  ]
}
```

---

## 5. 运行时侧职责

运行时**不依赖** Unity / NodeGraph / SceneBlueprint SDK，只需要：

### 5.1 数据加载

```
1. 读取 SceneBlueprintData（JSON 反序列化）
2. 构建行动表和过渡表的索引结构
```

### 5.2 行动处理器注册

```csharp
// 运行时 ActionHandler 映射
Dictionary<string, IActionHandler> handlers = new()
{
    ["Flow.Start"]        = new StartHandler(),
    ["Flow.End"]          = new EndHandler(),
    ["Flow.Delay"]        = new DelayHandler(),
    ["Combat.Spawn"]      = new SpawnHandler(),
    ["Combat.PlacePreset"] = new PlacePresetHandler(),
    ["Combat.BossPhase"]  = new BossPhaseHandler(),
    ["Presentation.Camera"] = new CameraHandler(),
    // ...
};

public interface IActionHandler
{
    void Activate(ActionEntry action, Blackboard blackboard);
    ActionStatus Tick(ActionEntry action, float deltaTime);
    void Cancel(ActionEntry action);
}
```

### 5.3 执行循环

```
BlueprintRunner 执行循环：
  1. 从 "Flow.Start" 行动开始
  2. 激活行动 → 调用对应 Handler.Activate()
  3. 每帧 Tick 活跃行动 → Handler.Tick() → 返回 Running / Completed / Failed
  4. 行动完成时，评估所有从该行动出发的 Transition
  5. Transition 条件满足 → 激活目标行动
  6. 所有行动完成（或到达 Flow.End） → 蓝图执行完毕
```

### 5.4 编辑器与运行时的唯一契约

| 契约项 | 说明 |
|-------|------|
| **TypeId 字符串** | 两边一致（"Combat.Spawn"） |
| **Property Key 字符串** | 两边一致（"interval"、"template"） |
| **ConditionData 格式** | 两边一致 |
| **SceneObjectId** | 两边一致（场景中的标识方式） |
| **AssetRef 标识** | 两边一致（资产名/配置表 ID） |

---

## 6. 数据格式选择

| 方案 | 说明 | 适用阶段 |
|------|------|---------|
| **JSON** | 人类可读，调试方便，Unity JsonUtility 或 Newtonsoft 支持 | 开发期（默认） |
| **FlatBuffers / Protobuf** | 二进制，解析快，体积小 | 发布期（可选） |
| **JSON 编辑 + Binary 发布** | 编辑器导出 JSON，发布时压缩为二进制 | 推荐的最终方案 |

Phase 1 使用 JSON，后续按需引入二进制格式。

---

## 7. 场景绑定跨项目传递

### 7.1 两层绑定架构

场景绑定在两层数据模型中的位置：

```
编辑器层（Unity 序列化）：
  蓝图（SO）图数据声明：子蓝图内节点需要 "Area 类型的 spawnArea"
  Manager 绑定数据（按子蓝图 ID 分组）：
    "子蓝图A" / "spawnArea" → spawn_area_north [GameObject 引用]
  策划在蓝图编辑器 Inspector 面板中拖入场景对象

导出边界 ─────────────────────────────────

运行时层（JSON）：
  SceneBindingEntry：{ BindingKey: "spawnArea", BindingType: "Area",
                       SourceSubGraph: "走廊战斗",
                       ExportedData: { vertices: [...] } }
```

**关键设计：**
- 蓝图（SO）不存场景对象引用——只在图中声明绑定需求
- 场景绑定在 Manager 中按子蓝图 ID 分组存储
- 策划通过蓝图编辑器 Inspector 面板配置绑定（Manager 自动管理）
- 导出时从 Manager 的 GameObject 引用提取坐标/ID 数据

### 7.2 导出策略：按 BindingType 分类

| BindingType | 编辑器中存储 | 导出方式 | 运行时查找 |
|------------|-------------|---------|-----------|
| **Transform** | GameObject 引用 | 导出 position + rotation | 数据自包含 |
| **Area** | GameObject 引用（含子物体顶点或 Collider） | 导出顶点坐标数组 | 数据自包含 |
| **Path** | GameObject 引用（子物体为路径点） | 导出路径点序列 | 数据自包含 |
| **Collider** | GameObject 引用 | 导出字符串 ID | 运行时按 ID 查找 |

### 7.3 导出 JSON 示例

```json
// Area 类型：导出顶点坐标（自包含）
{
  "BindingKey": "spawnArea",
  "BindingType": "Area",
  "SceneObjectId": "spawn_area_north",
  "ExportedData": {
    "vertices": [[1.0, 0.0, 2.0], [3.0, 0.0, 2.0], [3.0, 0.0, 5.0], [1.0, 0.0, 5.0]]
  }
}

// Transform 类型：导出位置和旋转（自包含）
{
  "BindingKey": "bossSpawn",
  "BindingType": "Transform",
  "SceneObjectId": "boss_spawn_point",
  "ExportedData": {
    "position": [5.0, 0.0, 10.0],
    "rotation": [0.0, 90.0, 0.0]
  }
}

// Collider 类型：仅导出字符串 ID（运行时查找）
{
  "BindingKey": "triggerZone",
  "BindingType": "Collider",
  "SceneObjectId": "corridor_trigger_01"
}
```

> **注意**：当前 SceneBindingEntry 的 `ExportedData` 字段需要扩展以支持坐标数据。
> 这将在 Phase 4C 实现时更新数据类。

---

## 8. 验证规则

BlueprintExporter 导出前执行的校验：

| 规则 | 级别 | 说明 |
|------|------|------|
| 必须有且仅有一个 Flow.Start | Error | 蓝图入口唯一 |
| 所有必填属性不为空 | Error | 根据 PropertyDefinition 检查 |
| 孤立节点警告 | Warning | 无连入也无连出的节点 |
| SceneBinding 引用存在 | Warning | 绑定的场景对象是否在场景中 |
| TypeId 已注册 | Error | ActionRegistry 中存在对应定义 |
| 端口连接合法 | Error | Out 端口连到 In 端口 |

---

## 9. 版本兼容

数据中包含 `Version` 字段，用于运行时兼容性检查：

```
Version 1: 初始版本
Version 2+: 如有字段新增/变更，运行时需要迁移逻辑
```

新增字段用可空/默认值保证向后兼容，删除字段用 Version 号区分。

---

## 10. 实施步骤与测试

### 测试基础设施

```
测试目录：Assets/Extensions/SceneBlueprint/Tests/（与 Phase 1 共用）
冒烟测试：通过 [MenuItem("SceneBlueprint/Tests/...")] 提供一键验证
```

---

### Step 1：纯数据类定义（0.5d）

**实现内容：**
- `SceneBlueprintData`（顶层容器）
- `ActionEntry`、`PropertyValue`、`TransitionEntry`、`ConditionData`
- `SceneBindingEntry`、`VariableEntry`

**测试用例：**

```csharp
[Test]
public void SceneBlueprintData_Create_HasCorrectStructure()
{
    var data = new SceneBlueprintData
    {
        BlueprintId = "test_01",
        BlueprintName = "测试蓝图",
        Version = 1,
        Actions = new[]
        {
            new ActionEntry { Id = "start", TypeId = "Flow.Start" },
            new ActionEntry
            {
                Id = "spawn_1", TypeId = "Combat.Spawn",
                Properties = new[]
                {
                    new PropertyValue { Key = "count", ValueType = "int", Value = "5" }
                }
            }
        },
        Transitions = new[]
        {
            new TransitionEntry
            {
                FromActionId = "start", FromPortId = "out",
                ToActionId = "spawn_1", ToPortId = "in",
                Condition = new ConditionData { Type = "Immediate" }
            }
        }
    };

    Assert.AreEqual("test_01", data.BlueprintId);
    Assert.AreEqual(2, data.Actions.Length);
    Assert.AreEqual(1, data.Transitions.Length);
    Assert.AreEqual("int", data.Actions[1].Properties[0].ValueType);
}

[Test]
public void ConditionData_Composite_CanNest()
{
    var cond = new ConditionData
    {
        Type = "AllOf",
        Children = new[]
        {
            new ConditionData { Type = "Delay", Expression = "3.0" },
            new ConditionData { Type = "Event", Expression = "boss_half_hp" }
        }
    };

    Assert.AreEqual(2, cond.Children.Length);
    Assert.AreEqual("Delay", cond.Children[0].Type);
}
```

**通过标准：** 所有数据类可正常构造和嵌套，字段赋值读取无误。

---

### Step 2：BlueprintExporter（1d）

**实现内容：**
- `BlueprintExporter.Export(Graph, IActionRegistry, IAssetIdResolver) → SceneBlueprintData`
- 遍历图中节点 → ActionEntry
- 遍历图中连线 → TransitionEntry
- ActionNodeData.Properties → PropertyValue[]

**测试用例：**

```csharp
[Test]
public void Exporter_SimpleGraph_ProducesCorrectData()
{
    // 构造一个简单的图：Start → Spawn → End
    var graph = CreateTestGraph_StartSpawnEnd();
    var registry = CreateRegistryWithAutoDiscover();
    var resolver = new DefaultAssetIdResolver();

    var data = BlueprintExporter.Export(graph, registry, resolver);

    Assert.AreEqual(3, data.Actions.Length);    // Start + Spawn + End
    Assert.AreEqual(2, data.Transitions.Length); // Start→Spawn, Spawn→End

    var spawnAction = data.Actions.First(a => a.TypeId == "Combat.Spawn");
    Assert.IsTrue(spawnAction.Properties.Any(p => p.Key == "monstersPerWave"));
}

[Test]
public void Exporter_PreservesPropertyValues()
{
    var graph = CreateTestGraph_StartSpawnEnd();
    // 给 Spawn 节点设置属性
    var spawnNode = graph.Nodes.First(n =>
        (n.UserData as ActionNodeData)?.ActionTypeId == "Combat.Spawn");
    ((ActionNodeData)spawnNode.UserData).Properties.Set("monstersPerWave", 8);

    var data = BlueprintExporter.Export(graph, CreateRegistryWithAutoDiscover(), new DefaultAssetIdResolver());

    var spawnAction = data.Actions.First(a => a.TypeId == "Combat.Spawn");
    var countProp = spawnAction.Properties.First(p => p.Key == "monstersPerWave");
    Assert.AreEqual("8", countProp.Value);
    Assert.AreEqual("int", countProp.ValueType);
}

[Test]
public void Exporter_TransitionCondition_Preserved()
{
    var graph = CreateTestGraph_WithDelayTransition(3.0f);

    var data = BlueprintExporter.Export(graph, CreateRegistryWithAutoDiscover(), new DefaultAssetIdResolver());

    var transition = data.Transitions[0];
    Assert.AreEqual("Delay", transition.Condition.Type);
    Assert.AreEqual("3", transition.Condition.Expression);
}
```

**通过标准：** 图中的节点、连线、属性值、条件数据均正确导出。

---

### Step 3：JSON 序列化/反序列化（0.5d）

**实现内容：**
- `BlueprintSerializer.ToJson(SceneBlueprintData) → string`
- `BlueprintSerializer.FromJson(string) → SceneBlueprintData`
- 格式化输出（便于阅读）

**测试用例：**

```csharp
[Test]
public void Serializer_JsonRoundTrip()
{
    var original = new SceneBlueprintData
    {
        BlueprintId = "test_roundtrip",
        BlueprintName = "往返测试",
        Version = 1,
        Actions = new[]
        {
            new ActionEntry
            {
                Id = "spawn_1", TypeId = "Combat.Spawn",
                Properties = new[]
                {
                    new PropertyValue { Key = "count", ValueType = "int", Value = "5" },
                    new PropertyValue { Key = "rate", ValueType = "float", Value = "2.5" },
                    new PropertyValue { Key = "name", ValueType = "string", Value = "精英组" }
                },
                SceneBindings = new[]
                {
                    new SceneBindingEntry { BindingKey = "area", BindingType = "Area", SceneObjectId = "zone_01" }
                }
            }
        },
        Transitions = new[]
        {
            new TransitionEntry
            {
                FromActionId = "start", FromPortId = "out",
                ToActionId = "spawn_1", ToPortId = "in",
                Condition = new ConditionData { Type = "Delay", Expression = "3.0" }
            }
        }
    };

    string json = BlueprintSerializer.ToJson(original);
    var restored = BlueprintSerializer.FromJson(json);

    Assert.AreEqual(original.BlueprintId, restored.BlueprintId);
    Assert.AreEqual(original.Actions.Length, restored.Actions.Length);
    Assert.AreEqual("5", restored.Actions[0].Properties[0].Value);
    Assert.AreEqual("zone_01", restored.Actions[0].SceneBindings[0].SceneObjectId);
    Assert.AreEqual("Delay", restored.Transitions[0].Condition.Type);
}

[Test]
public void Serializer_OutputIsReadableJson()
{
    var data = new SceneBlueprintData { BlueprintId = "readable", Version = 1 };
    string json = BlueprintSerializer.ToJson(data);

    Assert.IsTrue(json.Contains("\n")); // 格式化输出
    Assert.IsTrue(json.Contains("BlueprintId"));
}
```

**冒烟测试：**

```csharp
[MenuItem("SceneBlueprint/Tests/Step3 - JSON Export")]
static void SmokeTest_JsonExport()
{
    // 手动构造一个测试蓝图数据
    var data = CreateSampleBlueprintData();
    string json = BlueprintSerializer.ToJson(data);

    // 写入文件
    var path = "Assets/Extensions/SceneBlueprint/Tests/test_export.json";
    System.IO.File.WriteAllText(path, json);
    Debug.Log($"导出成功 → {path}");
    Debug.Log($"Actions: {data.Actions.Length}, Transitions: {data.Transitions.Length}");
    Debug.Log($"JSON 长度: {json.Length} 字符");

    // 反序列化验证
    var restored = BlueprintSerializer.FromJson(json);
    bool pass = restored.BlueprintId == data.BlueprintId
             && restored.Actions.Length == data.Actions.Length;
    Debug.Log($"往返验证: {(pass ? "✅ PASS" : "❌ FAIL")}");
}
```

**通过标准：** JSON 往返无损，输出格式可读，文件可正确写入和读取。

---

### Step 4：IAssetIdResolver（0.5d）

**实现内容：**
- `IAssetIdResolver` 接口
- `DefaultAssetIdResolver`（用资产名作为 ID）
- 可选：`ConfigTableIdResolver`（查配置表映射）

**测试用例：**

```csharp
[Test]
public void DefaultResolver_ReturnsAssetName()
{
    var resolver = new DefaultAssetIdResolver();
    // 模拟一个名为 "elite_group_01" 的资产
    string id = resolver.Resolve("elite_group_01");
    Assert.AreEqual("elite_group_01", id);
}

[Test]
public void DefaultResolver_NullAsset_ReturnsEmpty()
{
    var resolver = new DefaultAssetIdResolver();
    string id = resolver.Resolve(null);
    Assert.AreEqual("", id);
}
```

**通过标准：** 资产引用能正确转换为字符串标识。

---

### Step 5：导出验证规则（0.5d）

**实现内容：**
- `BlueprintValidator.Validate(Graph, IActionRegistry) → ValidationResult[]`
- `ValidationResult`（Level: Error/Warning, Message, NodeId）

**测试用例：**

```csharp
[Test]
public void Validator_NoStart_ReturnsError()
{
    var graph = CreateGraph_WithoutStart(); // 只有一个 Spawn 节点
    var results = BlueprintValidator.Validate(graph, CreateRegistryWithAutoDiscover());

    Assert.IsTrue(results.Any(r => r.Level == ValidationLevel.Error && r.Message.Contains("Start")));
}

[Test]
public void Validator_MultipleStart_ReturnsError()
{
    var graph = CreateGraph_WithTwoStarts();
    var results = BlueprintValidator.Validate(graph, CreateRegistryWithAutoDiscover());

    Assert.IsTrue(results.Any(r => r.Level == ValidationLevel.Error));
}

[Test]
public void Validator_OrphanNode_ReturnsWarning()
{
    var graph = CreateGraph_WithOrphanNode(); // Start → Spawn，另有一个孤立的 Delay 节点
    var results = BlueprintValidator.Validate(graph, CreateRegistryWithAutoDiscover());

    Assert.IsTrue(results.Any(r => r.Level == ValidationLevel.Warning && r.Message.Contains("孤立")));
}

[Test]
public void Validator_ValidGraph_NoErrors()
{
    var graph = CreateTestGraph_StartSpawnEnd(); // 合法的 Start → Spawn → End
    var results = BlueprintValidator.Validate(graph, CreateRegistryWithAutoDiscover());

    Assert.IsFalse(results.Any(r => r.Level == ValidationLevel.Error));
}

[Test]
public void Validator_UnknownTypeId_ReturnsError()
{
    var graph = CreateGraph_WithUnknownType(); // 包含一个 TypeId = "Unknown.X" 的节点
    var results = BlueprintValidator.Validate(graph, CreateRegistryWithAutoDiscover());

    Assert.IsTrue(results.Any(r => r.Level == ValidationLevel.Error && r.Message.Contains("TypeId")));
}
```

**通过标准：** 所有验证规则能正确识别错误/警告，合法图通过验证无 Error。

---

### Step 6：编辑器 UI 集成（0.5d）

**实现内容：**
- 蓝图编辑器工具栏添加"导出"按钮
- 导出前自动执行 Validate，显示结果
- 有 Error 时阻止导出并弹出提示
- 导出成功后在 Console 打印路径

**测试方式：** 纯手动冒烟测试

```
冒烟测试（编辑器窗口）：
  → 打开蓝图编辑器，创建合法图（Start → Spawn → End）
  → 点击"导出"按钮
  → Console 打印"导出成功 → xxx.json"
  → 打开文件确认 JSON 结构正确

  → 删除 Start 节点
  → 再次点击"导出"
  → 弹出错误提示"缺少 Start 节点"
  → 导出被阻止
```

**通过标准：** 导出按钮可用，验证拦截生效，成功导出的 JSON 正确。

---

### Step 7：场景绑定导出（1d）

**实现内容：**
- 位置类绑定（Area）→ 导出顶点坐标数组
- 引用类绑定（Transform）→ 导出字符串 ID
- Path 绑定 → 导出路径点序列

**测试用例：**

```csharp
[Test]
public void SceneBindingExport_Area_HasVertices()
{
    var binding = SceneBindingExporter.ExportArea(mockAreaObject);

    Assert.AreEqual("Area", binding.BindingType);
    Assert.IsNotNull(binding.ExportedData);
    // ExportedData 包含顶点坐标
}

[Test]
public void SceneBindingExport_Transform_HasStringId()
{
    var binding = SceneBindingExporter.ExportTransform(mockTransformObject, "boss_spawn_point");

    Assert.AreEqual("Transform", binding.BindingType);
    Assert.AreEqual("boss_spawn_point", binding.SceneObjectId);
}
```

**冒烟测试（编辑器窗口）：**

```
  → 在场景中放置一个 PolygonArea 对象
  → 在蓝图的 Spawn 节点 Inspector 中绑定该区域
  → 导出 JSON
  → 确认 SceneBindings 中包含顶点坐标数组
```

**通过标准：** 场景绑定数据完整导出，位置类数据自包含，引用类有正确 ID。

---

### Phase 3 整体通过标准

```
全部 Step 1~7 单元测试通过（Unity Test Runner 绿色）
Step 3 冒烟测试：导出 JSON 文件并往返验证 ✅ PASS
Step 6 冒烟测试：编辑器导出按钮可用，验证拦截正常
端到端：创建图 → 编辑属性 → 导出 JSON → 文件可读 → 反序列化一致
```

---

## 11. 相关文档

- [场景蓝图系统总体设计](场景蓝图系统总体设计.md)
- [Action与属性系统设计](Action与属性系统设计.md)
- [AI Director设计](_archive/AI%20Director设计.md)
