# 端口容量统一优化设计

**doc_status**: frozen  
**created**: 2026-02-19  
**last_reviewed**: 2026-02-19  
**实施状态**: ✅ S1–S5 全部完成（2026-02-19）

---

## 一、背景与问题

### 当前缺陷

`Port.Out()` 工厂方法默认创建 `PortCapacity.Single` 的控制流输出端口，导致几乎所有节点的输出端口只能连一条线。这造成了两个核心问题：

1. **策划体验差**：无法从一个节点的输出同时触发多个下游节点（如 Boss 出场时同时触发震动 + 警告文字），必须串联而非并联。
2. **设计不一致**：`Flow.Start` 和 `Flow.Join` 的输出端口已经意识到需要 Multiple，但通过手动绕过工厂方法实现，这是一种"补丁"。而 `Port.In()` 默认 Multiple 的设计使得一个节点可被多个上游连入，这与成熟框架的单一执行来源原则冲突，隐藏了竞争条件风险。

### 根本原因

`Port.In()` 和 `Port.Out()` 的默认容量与业界主流节点图框架（UE Blueprint、Unity Visual Scripting 等）的设计标准相反：

| 端口方向 | 当前默认值 | 业界标准 |
|---------|-----------|---------|
| Control 输入 | Multiple | **Single** |
| Control 输出 | Single | **Multiple** |

---

## 二、业界标准参考

UE Blueprint、Unity Visual Scripting（Bolt）、Godot VisualScript 等成熟框架均遵循同一规则：

```
执行流输出端口：Multiple（一个输出可同时触发多个下游）
执行流输入端口：Single（每个节点只能有一个确定的执行来源）
数据流输出端口：Multiple（一份数据可被多个下游消费）
数据流输入端口：Single（数据来源必须唯一）
```

**核心设计哲学**：
- 输出端不限制拓扑——"触发多个下游"是最基本的并联需求
- 输入端强制唯一来源——"执行从哪里来"必须是明确的，避免隐式竞争条件
- 多路汇合靠专门的 Join 节点显式完成（AND 语义），而非允许多个上游直连同一输入端口

---

## 三、优化目标

统一端口容量规则，与业界标准对齐：

| 工厂方法 | Kind | 当前 Capacity | 优化后 Capacity | 是否需要改 |
|---------|------|--------------|---------------|---------|
| `Port.In()` | Control, Input | Multiple | **Single** | ✅ 需改 |
| `Port.Out()` | Control, Output | Single | **Multiple** | ✅ 需改 |
| `Port.Event()` | Event, Output | Multiple | Multiple | 不变 |
| `Port.DataIn()` | Data, Input | Single | Single | 不变 |
| `Port.DataOut()` | Data, Output | Multiple | Multiple | 不变 |

新增一个特殊工厂方法：

| 新增方法 | Kind | Capacity | 用途 |
|---------|------|---------|------|
| `Port.InMulti()` | Control, Input | **Multiple** | 专供 Flow.Join 这类语义上需要接收多个输入的汇合节点 |

---

## 四、当前现状全量盘点

### 17 个节点端口容量一览

| 节点 TypeId | 输入端口 | 当前容量 | 优化后 | 输出端口 | 当前容量 | 优化后 |
|------------|---------|---------|--------|---------|---------|--------|
| Flow.Start | 无 | - | - | out（手动构造） | Multiple ✅ | 简化为 `Port.Out()` |
| Flow.End | in | Multiple ❌ | **Single** | 无 | - | - |
| Flow.Delay | in | Multiple ❌ | **Single** | out | Single ❌ | **Multiple** |
| Flow.Branch | in | Multiple ❌ | **Single** | true / false | Single ❌ | **Multiple** |
| **Flow.Join** | in | Multiple ⚡特例 | **保持 Multiple** | out（手动构造） | Multiple ✅ | 简化为 `Port.Out()` |
| Flow.Filter | in | Multiple ❌ | **Single** | pass / reject | Single ❌ | **Multiple** |
| Spawn.Wave | in | Multiple ❌ | **Single** | out / onWaveStart | Single ❌ | **Multiple** |
| Spawn.Preset | in | Multiple ❌ | **Single** | out | Single ❌ | **Multiple** |
| Spawn.Execute | in | Multiple ❌ | **Single** | out | Single ❌ | **Multiple** |
| Trigger.EnterArea | in | Multiple ❌ | **Single** | out | Single ❌ | **Multiple** |
| Condition.AllDead | entities（Data） | Single ✅ | 不变 | onAllDead（Event） | Multiple ✅ | 不变 |
| Behavior.Assign | in | Multiple ❌ | **Single** | out | Single ❌ | **Multiple** |
| VFX.CameraShake | in | Multiple ❌ | **Single** | out | Single ❌ | **Multiple** |
| VFX.ScreenFlash | in | Multiple ❌ | **Single** | out | Single ❌ | **Multiple** |
| VFX.ShowWarning | in | Multiple ❌ | **Single** | out | Single ❌ | **Multiple** |
| Location.RandomArea | 无 Flow 端口 | - | - | positions（Data） | Multiple ✅ | 不变 |
| Monster.Pool | 无 Flow 端口 | - | - | monsters（Data） | Multiple ✅ | 不变 |

**汇总**：
- 需要将 `in` 端口从 Multiple → Single 的节点：**12 个**
- 需要将 Control 输出端口从 Single → Multiple 的节点：**12 个**（含 onWaveStart）
- Flow.Join 的 `in` 端口是唯一特例，需要保持 Multiple
- Flow.Start、Flow.Join 的输出端口已是 Multiple，但可以简化代码（手动构造 → `Port.Out()`）

---

## 五、各改动点详述

### 5.1 核心改动：`PortDefinition.cs` — Port 工厂方法

**改动一**：`Port.In()` Capacity 改为 Single，并更新注释

```csharp
// 改前：
public static PortDefinition In(string id, string displayName = "")
{
    return new PortDefinition
    {
        ...
        Capacity = PortCapacity.Multiple  // 旧
    };
}

// 改后：
public static PortDefinition In(string id, string displayName = "")
{
    return new PortDefinition
    {
        ...
        Capacity = PortCapacity.Single  // 新：每个节点只能有一个确定的执行来源
    };
}
```

**改动二**：`Port.Out()` Capacity 改为 Multiple，并更新注释

```csharp
// 改前：
public static PortDefinition Out(string id, string displayName = "")
{
    return new PortDefinition
    {
        ...
        Capacity = PortCapacity.Single  // 旧
    };
}

// 改后：
public static PortDefinition Out(string id, string displayName = "")
{
    return new PortDefinition
    {
        ...
        Capacity = PortCapacity.Multiple  // 新：输出可以同时触发多个下游
    };
}
```

**改动三**：新增 `Port.InMulti()` 工厂方法

```csharp
/// <summary>
/// 创建控制流输入端口（多连接，仅供汇合类节点使用）。
/// <para>
/// 普通节点应使用 <see cref="In"/>（Single）。
/// 仅当节点的语义是"等待多个上游汇合"时（如 Flow.Join），才使用此方法。
/// </para>
/// </summary>
public static PortDefinition InMulti(string id, string displayName = "")
{
    return new PortDefinition
    {
        Id = id,
        DisplayName = displayName,
        Kind = PortKind.Control,
        Direction = PortDirection.Input,
        Capacity = PortCapacity.Multiple
    };
}
```

同时更新文件头部的设计说明注释，从：
```
- 输入端口通常是 Multiple（允许多个前置行动连入）
- 流程输出端口通常是 Single（只走一条路径）
```
改为：
```
- 控制流输入端口：Single（执行来源必须唯一，避免竞争条件）
  特例：Flow.Join 类汇合节点使用 Port.InMulti()，语义是"等待多个上游"
- 控制流输出端口：Multiple（一个完成点可以并联触发多个下游）
- 事件输出端口：Multiple（同上）
- 数据输入端口：Single（数据来源必须唯一）
- 数据输出端口：Multiple（同一数据可被多个下游消费）
```

---

### 5.2 Flow.JoinDef — 改用 `Port.InMulti()`

`FlowJoinDef.cs` 的 `in` 端口从 `Port.In()` 改为 `Port.InMulti()`，输出端口从手动构造简化为 `Port.Out()`：

```csharp
// 改前：
Ports = new[]
{
    Port.In("in", "输入"),                    // Multiple（隐式，但不再是默认行为）
    new PortDefinition                        // 手动构造 Multiple 输出
    {
        Id = "out", DisplayName = "输出",
        Kind = PortKind.Control,
        Direction = PortDirection.Output,
        Capacity = PortCapacity.Multiple
    }
}

// 改后：
Ports = new[]
{
    Port.InMulti("in", "输入"),   // 明确的汇合语义
    Port.Out("out", "输出")       // 改后 Port.Out() 默认就是 Multiple
}
```

---

### 5.3 Flow.StartDef — 简化手动构造

`FlowStartDef.cs` 的 `out` 端口从手动构造简化为 `Port.Out()`：

```csharp
// 改前：手动构造 Multiple 输出
new PortDefinition
{
    Id = "out", DisplayName = "输出",
    Kind = PortKind.Control,
    Direction = PortDirection.Output,
    Capacity = PortCapacity.Multiple
}

// 改后：
Port.Out("out", "输出")   // Port.Out() 改后默认 Multiple，语义相同
```

---

### 5.4 其余节点 — 无需改动节点代码

由于工厂方法默认值统一变更，以下节点的代码**无需任何修改**，端口容量自动正确：

- Flow.End, Flow.Delay, Flow.Branch, Flow.Filter
- Spawn.Wave, Spawn.Preset, Spawn.Execute
- Trigger.EnterArea, Behavior.Assign
- VFX.CameraShake, VFX.ScreenFlash, VFX.ShowWarning

---

## 六、编辑器层影响分析

### 6.1 DefaultConnectionPolicy.cs — 无需改动

`DefaultConnectionPolicy.CanConnect()` 第 96~102 行已经同时对输出端口和输入端口做容量检查：

```csharp
if (outPort.Capacity == PortCapacity.Single && !sourceBoundary && !targetBoundary
    && graph.GetEdgesForPort(outPort.Id).Any())
    return ConnectionResult.CapacityExceeded;

if (inPort.Capacity == PortCapacity.Single && !sourceBoundary && !targetBoundary
    && graph.GetEdgesForPort(inPort.Id).Any())
    return ConnectionResult.CapacityExceeded;
```

优化后：
- 输出端口改为 Multiple → 第一条检查不再触发，输出端口不再受容量限制
- 输入端口改为 Single → 第二条检查正常生效，阻止多条线连入同一输入端口
- 该文件**无需改动**

### 6.2 ConnectCommand.cs — 行为自动正确

`ConnectCommand.Execute()` 第 39~52 行已有 Single 目标端口的自动替换逻辑：

```csharp
var targetPort = graph.FindPort(_targetPortId);
if (targetPort != null && targetPort.Capacity == PortCapacity.Single)
{
    // 记录旧连线 → 执行时自动断开旧线再连新线
}
```

输入端口改为 Single 后，当用户把新线拖到已有连线的输入端口上，旧连线会被自动替换（而非报错）。这是期望的 UX 行为，与 UE Blueprint 的交互一致。该文件**无需改动**。

### 6.3 编辑器渲染 — Multiple Input 特殊 UI 消失

`GraphViewModel` 和 `UnityGraphRenderer` 对 `Input + Multiple` 端口有专属渲染：堆叠圆圈 + "+" 槽位按钮。

优化后，普通 Control 输入端口变为 Single，不再触发这套特殊渲染。只有 `Flow.Join` 的 `in` 端口（InMulti）保留这套 UI，语义也更清晰。

该渲染逻辑**无需改动**，只是触发频率降低了。

---

## 七、运行时影响分析

### 7.1 TransitionSystem — 无需改动

当前 `TransitionSystem` 对 `PortEvent` 的激活逻辑：

```
节点 Idle → 首次被激活 → Running
节点 Running → 再次被激活 → 忽略（或 SoftReset for Listening 状态）
```

优化后，编辑器层已经不允许多个上游连入同一输入端口，运行时不再出现"同帧两个 PortEvent 激活同一节点"的情况（Flow.Join 例外，它有独立的 FlowJoinSystem 处理）。

**无需改动**。

### 7.2 Flow.Join 兼容性

`FlowJoinDef` 改用 `Port.InMulti()`，端口容量保持 Multiple，`FlowJoinSystem` 逻辑不受影响。

---

## 八、序列化兼容性

> 前提：用户已明确"旧数据全部废弃，不做兼容检测"。

- `Port.Capacity` 由 `NodeTypeDefinition` 中的 `PortDefinition` 决定，并在反序列化时从 JSON 还原（`Port.cs` 的 `internal Port(...)` 构造）
- 已有蓝图 JSON 中端口 Capacity 仍是旧值，直到节点被重新创建
- 由于旧数据废弃，无需迁移脚本

---

## 九、实施步骤

| 步骤 | 文件 | 改动内容 |
|-----|------|---------|
| S1 | `SceneBlueprint/Core/PortDefinition.cs` | `Port.In()` 改 Single；`Port.Out()` 改 Multiple；新增 `Port.InMulti()`；更新文件头注释 |
| S2 | `Actions/Flow/FlowJoinDef.cs` | `Port.In()` → `Port.InMulti()`；手动构造输出 → `Port.Out()` |
| S3 | `Actions/Flow/FlowStartDef.cs` | 手动构造输出 → `Port.Out()` |
| S4 | 验收 | 在编辑器中验证所有节点的输出端口可以连多条线，输入端口只能连一条线 |

**注意**：S1 完成后 S2/S3 可同步进行（无依赖关系）。其余 12 个节点无需改动。

---

## 十、验收标准

- [ ] `Port.Out()` 创建的端口容量为 Multiple，可在编辑器中向同一输出端口连多条线
- [ ] `Port.In()` 创建的端口容量为 Single，向已有连线的输入端口拖线时自动替换旧连线
- [ ] `Flow.Join` 的 `in` 端口仍为 Multiple（堆叠圆圈 + "+" UI 保留）
- [ ] `Flow.Start` 和 `Flow.Join` 的输出端口代码简化为 `Port.Out()`，行为与之前一致
- [ ] 原有 `Condition.AllDead`、`Location.RandomArea`、`Monster.Pool` 等节点行为不受影响
- [ ] 在蓝图中验证：`Flow.Filter.pass` 可同时连接 `VFX.CameraShake.in` 和 `VFX.ShowWarning.in`（这是触发这次优化的原始需求）

---

## 十一、子图（SubGraph）专项分析

### 11.1 两处硬编码问题

`SubGraphInstantiator.InferBoundaryPorts`（用于从模板实例化子图）和 `GroupNodesCommand.InferBoundaryPorts`（用于就地打包选中节点）都硬编码了边界端口容量为 `PortCapacity.Single`，与优化后的 `Port.Out()` 默认 Multiple **不一致**：

```csharp
// SubGraphInstantiator.cs 第 161/175 行
// GroupNodesCommand.cs 第 181/197/211/216 行
// 两处都写死了：
info.PortDefinitions.Add(new PortDefinition(
    repPortName, PortDirection.Output, sp.Kind,
    sp.DataType, PortCapacity.Single, outputOrder++));  // ← 应改为 Multiple
```

**Output 边界端口（"完成"）**：硬编码 Single，应改为 Multiple（子图完成后同样可以触发多个下游）。  
**Input 边界端口（"激活"）**：硬编码 Single，由于豁免机制（见 11.2），功能上无区别，保持不变即可。

### 11.2 边界端口豁免机制与 Single Input 的语义冲突

`DefaultConnectionPolicy` 对边界端口豁免容量检查（`!sourceBoundary && !targetBoundary` 条件），分为两种场景：

- **场景 A（内部桥接）**：边界端口 ↔ 子图内节点 → 完全豁免方向/容量检查
- **场景 B（外部连接）**：外部节点 ↔ 边界端口 → 边界端口跳过容量检查

这导致一个"开洞"：即使内部节点的 `in` 端口是 Single，外部仍可通过边界端口间接形成多来源：

```
[外部A].out ─→ [边界.in "激活"] ─→ [内部节点.in]
[外部B].out ─→ ↗
             场景B：边界端口跳过容量  +  场景A：内部桥接豁免容量
             → 内部 Single in 端口被绕过
```

### 11.3 设计决策：接受这个"开洞"（方案 X）

对比两个方向：

| | 方案 X（接受）| 方案 Y（严格关闭）|
|--|--------------|----------------|
| 语义 | 子图是封装单元，边界端口是"接口"，允许被多处调用 | 子图输入也强制唯一来源 |
| 实现成本 | 无需改动 DefaultConnectionPolicy | 需要为边界端口也做容量检查（破坏现有豁免机制）|
| 策划体验 | 灵活（一个子图可被多处触发）| 受限（需要在子图外先加 Flow.Join） |
| 与函数调用类比 | 一致（函数可以被多处调用）| 不一致 |

**结论：采用方案 X，接受边界端口的多来源能力。**  
理由：子图 = 封装的行动序列，被多处调用是合理语义；强制单来源会大幅增加策划使用子图的心智负担。边界端口的豁免机制是 NodeGraph 框架有意设计的，不应破坏。

### 11.4 子图专项改动清单

| 步骤 | 文件 | 改动内容 |
|-----|------|---------|
| S4 | `NodeGraph/Core/SubGraphInstantiator.cs` | `InferBoundaryPorts` 中 Output 边界端口从 `PortCapacity.Single` 改为 `PortCapacity.Multiple` |
| S5 | `NodeGraph/Commands/GroupNodesCommand.cs` | 同上（两处：正常路径第 181 行 + 默认补全第 216 行） |

---

## 十二、变更影响范围总结

| 维度 | 影响 |
|-----|------|
| 改动文件数 | **5 个**（PortDefinition.cs、FlowJoinDef.cs、FlowStartDef.cs、SubGraphInstantiator.cs、GroupNodesCommand.cs） |
| 其余节点代码 | 无需改动（工厂方法默认值传播） |
| 编辑器连接策略 | 无需改动 |
| 运行时系统 | 无需改动 |
| 子图豁免机制 | 无需改动（方案 X，保持现有设计） |
| 已有蓝图数据 | 旧数据废弃，无兼容需求 |
| 策划体验 | 显著提升：输出端口可并联，子图可被多处调用 |
